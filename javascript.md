# <img src="https://img.shields.io/badge/HTML5-E34F26?style=for-the-badge&logo=html5&logoColor=white"/> <img src="https://img.shields.io/badge/CSS3-1572B6?style=for-the-badge&logo=css3&logoColor=white"/> <img src="https://img.shields.io/badge/JavaScript-323330?style=for-the-badge&logo=javascript&logoColor=F7DF1E"/> <img src="https://img.shields.io/badge/Bootstrap-563D7C?style=for-the-badge&logo=bootstrap&logoColor=white" /> <img src="https://img.shields.io/badge/Font_Awesome-339AF0?style=for-the-badge&logo=fontawesome&logoColor=white" />

# Ä°Ã‡Ä°NDEKÄ°LER

---

## 4. Javascript Dersleri

## 4.1-Javascript Nedir?

Javascript web programlama alanÄ±nda yaygÄ±n olarak kullanÄ±lan dinamik bir programlama dilidir. EtkileÅŸimli ve dinamik web sayfalarÄ± geliÅŸtirmeye yardÄ±mcÄ± olur. Ä°sminden dolayÄ± Java programala dili ile karÄ±ÅŸtÄ±rÄ±lÄ±r ancak her iki dilde birbirinden Ã§ok farklÄ± birer dildir. AralarÄ±ndaki benzerlik; yazÄ±m ÅŸekli ve standart kÃ¼tÃ¼phanelerÄ± dÄ±ÅŸÄ±nda bir baÄŸlantÄ± yoktur.

C programlama dilinden tÃ¼retilmiÅŸ, semantiÄŸi ve tasarÄ±mÄ± ise Self ve Sheme programlama dillerinden esinlenmiÅŸtir.

Javascript dili 1997 yÄ±lÄ±nda Netscape ÅŸirketinde Ã§alÄ±ÅŸan Brendan Eich tarafÄ±ndan gliÅŸtirilmiÅŸtir. Ä°lk Ã§Ä±ktÄ±ÄŸÄ± yÄ±llarda o deneme iat web tarayÄ±cÄ±larÄ±n bÃ¼yÃ¼k Ã§oÄŸunluÄŸu tarafÄ±ndan yorumlanamÄ±yordu ancak Brendan Eich bu dili geliÅŸtirmeye devam etti.Brendan Eich o dÃ¶nemlerde Mozilla VakfÄ±â€™nÄ± kurdu. Bu vakÄ±f gÃ¼nÃ¼mÃ¼zde hÃ¢lÃ¢ Javascript dilini geliÅŸtirmeye devam etmektedir.

### 4.2-ECMAScript'in Ortaya Ã‡Ä±kÄ±ÅŸÄ±

1996 yÄ±lÄ±nÄ±n kasÄ±m ayÄ±nda Netscape firmasÄ± Javascript'in endÃ¼stri standardÄ± olarak belirlenmesi amacÄ±yla ECMA International'a (Avrupa Bilgisayar Ãœreticileri BirliÄŸi) baÅŸvuruda bulunduÄŸunu ilan etti. Bunun sonucunda standardize edilen sÃ¼rÃ¼m ECMAJcript olarak isimlendirildi ve 1997 yÄ±lÄ±nÄ±n haziran ayÄ±nda ECMA International, ECMA-262 standartlarÄ± Ã§erÃ§evesinde ilk sÃ¼rÃ¼m ECMAScript (kÄ±saca ES) yanÄ±mlandÄ±.Haziran 1998'de ISO/IEC-16262 standardÄ±na uyumlu hale getirilecek deÄŸiÅŸiklikler yapÄ±larak ECMAScript 2, AralÄ±k 1999'da ise ECMAScript 3 yayÄ±nlandÄ±.

ECMAScript 4 Ã¼zerinde ciddi bir Ã§alÄ±ÅŸma yapÄ±lmasÄ±na raÄŸmen asla tamamlanamadÄ±, ancak beÅŸinci sÃ¼rÃ¼m iÃ§in Ã¶nemli bir ilham kaynaÄŸÄ± oldu. ECMAScript 5, 2009 yÄ±lÄ±nÄ±n AralÄ±k ayÄ±nda yayÄ±nlandÄ±. En son yayÄ±nlanan versiyonu ECMAScript 2020, Haziran 2020'de yayÄ±nladÄ±.

**ECMAScript VersiyonlarÄ±**

```
1. ES1 / ECMAScript 1 (Haziran 1997)
2. ES2 / ECMAScript 2 (Haziran 1998)
3. ES3 / ECMAScript 3 (AralÄ±k 1999)
- ES4 / ECMAScript 4 (YayÄ±nlanmadÄ±)
4. ES5 / ECMAScript 5 (AralÄ±k 2009)
5. ES5.1 / ECMAScript 5.1 (Haziran 2011)
6. ES6 / ECMAScript 2015 (Haziran 2015)
7. ES2016 / ECMAScript 2016 (Haziran 2016)
8. ES2017 / ECMAScript 2017 (Haziran 2017)
9. ES2018 / ECMAScript 2018 (Haziran 2018)
10. ES2019 / ECMAScript 2019 (Haziran 2019)
11. ES2020 / ECMAScript 2020 (Haziran 2020)
```

## 4.3-JavaScript KullanÄ±m AlanlarÄ±

JavaScript'in tarihi konusunda da belirteceÄŸimiz gibi, JavaScript'in ortaya Ã§Ä±kÄ±ÅŸ amacÄ± siteleri interaktif ve fonksiyonel hale getirmekti. Ancak ECMA StandartÄ± ile hÄ±zla deÄŸiÅŸen ve geliÅŸen JavaScript, yazÄ±lÄ±mcÄ±larÄ±n talepleri doÄŸrultusunda sÃ¼rekli Ã¼zerine koyarak ve yeni bir dÃ¶nem baÅŸlatan Node.js'in geliÅŸtirilmesiyle, oldukÃ§a Ã¶nemli gÃ¼ncellemeler de alarak her alanda kullanabilecek bir dil haline geldi. BÃ¶ylece tÃ¼m dÃ¼nyanÄ±n en Ã§ok kullanÄ±lan yazÄ±lÄ±m dili olarak son yÄ±llarda hep ilk sÄ±ralarda yer edinmeyi baÅŸardÄ±.

**JavaScript'in kullanÄ±labileceÄŸi alanlar:**

- Front-end
- Back-end
- Mobil (Mobile)
- MasaÃ¼stÃ¼ (Desktop)
- Oyun (Game)
- Makine Ã–ÄŸrenmesi, Derin Ã–ÄŸrenme ve Yapay Zeka (Machine Learning, Deep Learning & Artificial Intelligence)

## 4.4-DeÄŸiÅŸken (Variable) TanÄ±mlama

Programlama dillerinde sÄ±kÃ§a verileri bellek yani RAM de saklamamÄ±z gerekir. RAM iÅŸlem yapmak iÃ§in son derece hÄ±zlÄ± bir donanÄ±mdÄ±r.
BasitÃ§e, bellke iÃ§erisindeki bir alanÄ±n adlandÄ±rÄ±lmasÄ±na ve ayrÄ±lmasÄ±na deÄŸiÅŸken tanÄ±mlamak denir.

- DeÄŸiÅŸken isimleri harf, \_ veya $ iÅŸareti ile baÅŸlayabilir. Fakat ES5 (ECMAScript 5) birlikte gelen Ã¶zellikle UNICODE kodlarÄ± kullanÄ±lÄ±rken kaÃ§Ä±ÅŸ karakteri olarak kullanÄ±lan \ iÅŸareti ilk karakter olarak kullanÄ±labilir.
- Ä°lk harften sonra deÄŸiÅŸken isimlerinde rakamlar da kullanÄ±labilir. $ ve \_ dÄ±ÅŸÄ±nda baÅŸka noktalama iÅŸaretleri kullanÄ±lamaz
- DeÄŸiÅŸken ismindeki harfler arasÄ±nda boÅŸluk kullanÄ±lamaz.

## 4.5-DeÄŸiÅŸkene DeÄŸer Atama ve Veri TÃ¼rleri

DeÄŸiÅŸkenlere deÄŸer atama = operatÃ¶rÃ¼ ile yapÄ±lÄ±r.  
JavaScript loosely typed bir programlama dilidir. Yani bir deÄŸiÅŸkeni tanÄ±mlarken deÄŸiÅŸkenin tÃ¼rÃ¼nÃ¼ (sayÄ±sal, metinsel, boolean) belirtmemize gerek yoktur.  
Bir deÄŸiÅŸkene aÅŸaÄŸÄ±daki veri tiplerini atayabiliriz.

- Boolean = MantÄ±ksal ifadedir. _true_ veya _false_ deÄŸeri atanabilir
- Number = SayÄ±sal ifadedir. 2^53 -1 deÄŸerine kadar sayÄ±sal deÄŸerler atanabilir.
- BigInt = 2^53-1 deÄŸerinden bÃ¼yÃ¼k deÄŸerleri atayabilir.
- String = Metinsel ifadelerdir. Metinsel ifade tanÄ±mlanÄ±rken ifade â€œ â€ veya â€˜ â€™ iÅŸaretleri arasÄ±na yazÄ±lÄ±r.
- Object = YukarÄ±da ki 7 veri tÃ¼rÃ¼ de primitive tiplidir. Objelerde ( nesne, dizi ) gibi referans tipler de deÄŸiÅŸkenlere atanabilir.

**var ile deÄŸiÅŸken tanÄ±mlama**
Global scope veya function scope'ta deklarasyon saÄŸlayamaya yarayan keyword'dur. Scope Ã¶zelliklerini daha sonra Ã¶rneklerle aÃ§Ä±klayacaÄŸÄ±z. var ile tanÄ±mlanan deÄŸiÅŸkenlerin Ã¶zellikleri ÅŸunlardÄ±r.

- DeÄŸiÅŸken deÄŸerleri deÄŸiÅŸtirilebilir.
- AynÄ± isimle tekrardan tanÄ±mlanabilirler.
- var ile tanÄ±mlanan deÄŸiÅŸkenler global scope veya function scope'tur. Global scope'ta tanÄ±mlanan deÄŸiÅŸkenlere her yerden ulaÅŸÄ±labilir. Function iÃ§erisinde tanÄ±mlanan deÄŸiÅŸkenlere ise tanÄ±mlÄ± olduÄŸu fonksiyonda ulaÅŸÄ±labilir.

**Anahtar Notlar :**  
ES6 ile birlikte var kullanÄ±mÄ± _decepricate_ olmuÅŸtur ve yerine _let_ ve _const_ gelmiÅŸtir. Bu keyword ler bize _var_ Ä±n saÄŸlayamadÄ±ÄŸÄ± Ã¶zellikleride saÄŸlamaktadÄ±r.

**let ile deÄŸiÅŸken tanÄ±mlama**
DeÄŸiÅŸkenleri block scope'ta tanÄ±mlayan deklarasyondur. let ile tanÄ±mlanan deÄŸiÅŸkenlerin Ã¶zellikleri ÅŸunlardÄ±r.

- DeÄŸiÅŸken deÄŸerleri deÄŸiÅŸtirilebilir.
- AynÄ± isimle tekrardan aynÄ± blokta tanÄ±mlanamaz. FarklÄ± block'larda aynÄ± isimle tanÄ±mlanabilir.

**const ile deÄŸiÅŸken tanÄ±mlama**
Block scope da tanÄ±mlÄ±, deÄŸeri sonradan deÄŸiÅŸtirilemez deÄŸiÅŸkenleri deklare etmek iÃ§in kullanÄ±lan keyword'dÃ¼r.

- Const ile tanÄ±mlanan objelerin Ã¶zellikleri (properties) deÄŸiÅŸtirilebilir fakat objenin kendisi deÄŸiÅŸtirilemez. Diziler iÃ§inde aynÄ±sÄ±
- geÃ§erlidir. Dizi deÄŸerleri deÄŸiÅŸtirilebilir fakat dizinin kendisi deÄŸiÅŸtirilemez.

## 4.6-Hoisting

DeÄŸiÅŸkenlerden bahsederken, deÄŸiÅŸkenleri kullanÄ±p daha sonra tanÄ±mlamamÄ±zÄ± saÄŸlayan hoisting kavramÄ±ndan da bahsetmemiz gerekir. JavaScriptâ€™te tanÄ±mlanan deÄŸiÅŸkenler yorumlanÄ±rken tanÄ±mladÄ±ÄŸÄ±nÄ±z deÄŸiÅŸkenler fonksiyon veya ifadenin yukarÄ±sÄ±na alÄ±narak yorumlanÄ±r. Buna hoisting (yukarÄ± alma) denir. YukarÄ±ya alÄ±nan deÄŸiÅŸkenler var ile deklare edildiyse atandÄ±klarÄ± deÄŸer yerine undefined deÄŸerini alÄ±r. let veya const ile deklare edildi ise ReferanceError hatasÄ± verir. let ve const ile deklare edilen deÄŸiÅŸkenler bloÄŸun baÅŸlangÄ±cÄ±ndan itibaren tanÄ±mÄ±nÄ±n yapÄ±ldÄ±ÄŸÄ± yere kadar kadar geÃ§ici (temporal dead zone) bÃ¶lgededir.

## 4.7- Javascript Veri TÃ¼rleri

Veri tÃ¼rleri her programlama dili iÃ§in oldukÃ§a Ã¶nemli bir kavramdÄ±r. Veri tÃ¼rÃ¼, deÄŸiÅŸkenler iÃ§inde saklanacak verinin tÃ¼rÃ¼ne gÃ¶re sÄ±nÄ±flandÄ±rÄ±lmasÄ± iÅŸlemidir.

JavaScript, C# veya Java gibi diÄŸer programa dillerine benzer veri tiplerini iÃ§erir. Genel olarak iki veri tÃ¼rÃ¼ olarak sÄ±nÄ±flandÄ±rabiliriz;

1- Ä°lkel (Primitive) Veri TÃ¼rleri

- String
- Number
- Boolean
- Undefined
- Null
- Symbol
- Bigint

2- Ä°lkel Olmayan (Reference) Veri TÃ¼rleri

- Object
- Array
- Function

JavaScript dinamik bir dildir, yani bir deÄŸiÅŸken herhangi bir zamanda herhangi bir veri tÃ¼rÃ¼nÃ¼ tutabilir. Ã–rneÄŸin :

```
var x = 100;
x = "javascript";
x = false;
x = null;
x = undefined;

alert(x); // undefined
```

x deÄŸiÅŸkeni en son atanmÄ±ÅŸ undefined deÄŸerini tutacaktÄ±r.

**typeof** operatÃ¶rÃ¼ ile bir deÄŸiÅŸkenin veri tipini Ã¶ÄŸrenebiliriz. EÄŸer ki object iÃ§indeki herhangi bir yapÄ±sal tipi kontrol etmek istersek, bunun iÃ§in _typeof_ kullanmak anlamsÄ±z olur, Ã§Ã¼nkÃ¼ her zaman â€œobjectâ€ Ã§Ä±ktÄ±sÄ±nÄ± alÄ±rÄ±z. Bu tarz bir durumda kesin bir sonuÃ§ alÄ±namasa da **instanceof** operatÃ¶rÃ¼nÃ¼ kullanmak mantÄ±klÄ± olabilir.

## 4.8-Number Veri TÃ¼rÃ¼ KullanÄ±mÄ±, Temel Aritmetik Ä°ÅŸlemler ve Ä°ÅŸlem Ã–nceliÄŸi ve ArttÄ±rma ve Azaltma Ä°ÅŸlemleri

**Number (SayÄ±) Veri TÃ¼rÃ¼**

JavaScript dili weakly-typed yani gÃ¼Ã§sÃ¼z tÃ¼rlÃ¼ bir dildir. DeÄŸiÅŸkenlerin ve parametrelerin tÃ¼rlerini bildirmek gerekmez. TÃ¼r kullanÄ±mdan dolaylÄ± olarak Ã§Ä±kartÄ±lÄ±r.  
Ã–rneÄŸin:

```
let x = 3;
```

ÅŸeklindeki tanÄ±mlamada deÄŸiÅŸkenin deÄŸeri tam sayÄ± (integer), aÅŸaÄŸÄ±daki Ã¶rnekte ise

```
let y = 3.14;
```

y deÄŸiÅŸkenin deÄŸer tÃ¼rÃ¼ kayan sayÄ± (float) tÃ¼rÃ¼ndedir. SayÄ±nÄ±n integer veya float olup olmadÄ±ÄŸÄ± nokta (.) olup olmamasÄ±ndan anlaÅŸÄ±lÄ±r.

**Aritmetik OperatÃ¶rler**

- Toplama: +
- Ã‡Ä±karma: -
- Ã‡arpma: \*
- Ãœs Alma: \*\*
- BÃ¶lme: /
- Mod Alma: %
- ArttÄ±rma: ++
- Eksiltme: --

**Toplama:** SayÄ±larÄ± toplama iÅŸlemini gerÃ§ekleÅŸtirir. Ä°ÅŸlem yÃ¶nÃ¼ soldan saÄŸadÄ±r.

```
    var result = 3+5;
    console.log(result);
    //8
```

**Ã‡Ä±karma:** Ä°ki sayÄ±yÄ± Ã§Ä±karma iÅŸlemini gerÃ§ekleÅŸtirir. Ä°ÅŸlem yÃ¶nÃ¼ soldan saÄŸadÄ±r.

```
    var result = 5-2;
    console.log(result);
    //3
```

**Ã‡arpma:** Ä°ki sayÄ±yÄ± Ã§arpma iÅŸlemini gerÃ§ekleÅŸtirir. Ä°ÅŸlem yÃ¶nÃ¼ soldan saÄŸadÄ±r.

```
    var result = 5*2;
    console.log(result);
    //10
```

**Ãœs Alma:** ECMAScript6 ile gelmiÅŸtir. Soldaki deÄŸerin, saÄŸdaki rakam veya sayÄ± baz alÄ±narak kendisiyle Ã§arpÄ±lmasÄ± ÅŸeklinde gerÃ§ekleÅŸir.

```
    var result = 5**2;
    console.log(result);
    //25
```

**BÃ¶lme:** Ä°ki sayÄ±yÄ± bÃ¶lme iÅŸlemini gerÃ§ekleÅŸtirir. Ä°ÅŸlem yÃ¶nÃ¼ soldan saÄŸadÄ±r.

```
    var result = 6/3;
    console.log(result);
    //2
```

**Mod Alma:** OperatÃ¶rÃ¼n solundaki deÄŸerin saÄŸdakine kalanÄ±nÄ± bulmak iÃ§in kullanÄ±lmaktadÄ±r. Ä°ÅŸlem yÃ¶nÃ¼ soldan saÄŸadÄ±r.

```
    var result = 6%3;
    console.log(result);
    //0
```

**Azaltma:** Bir sayÄ±yÄ± azaltmak iÃ§in kullanÄ±rÄ±z. DeÄŸeri 1 azaltÄ±r. For ve While dÃ¶ngÃ¼leri iÃ§inde sÄ±k sÄ±k kullanÄ±lÄ±r. ArttÄ±rma operatÃ¶rÃ¼nde anlatÄ±lan baÅŸa veya sonraya operatÃ¶r ekleme iÅŸlemi sonunda gerÃ§ekleÅŸen durum azaltma operatÃ¶rÃ¼ iÃ§inde geÃ§erlidir.

```
    let counter = 1;
    let a = --counter;
    alert(a); // 0
```

## 4.9-Boolean Veri TÃ¼rÃ¼

Program yazarken sadece iki ifade ile Ã§alÄ±ÅŸmak (evet yada hayÄ±r, _0_ yada _1_ gibi) programÄ±n anlaÅŸÄ±labilmesi ve yazÄ±m kolaylÄ±ÄŸÄ± aÃ§Ä±sÄ±ndan Ã§ok iÅŸimize yarar. Ä°ÅŸte bu veri tÃ¼rÃ¼nde ise iki ifade vardÄ±r. Bunlar _true_ ve _false_ tir.

```
Boolean(10>9); // true
```

```
Boolean(10>11); // false
```

```
const b1 = Boolean(100); // true
const b2 = Boolean(3.14); // true
const b3 = Boolean(-15); // true
const b4 = Boolean("Hello"); // true
const b5 = Boolean('false'); // true
const b6 = Boolean(1 + 7 + 3.14); // true
```

```
const c1 = Boolean(undefined); // false
const c2 = Boolean(null); // false
const c3 = Boolean(""); // false
const c4 = Boolean(false); // false
const c5 = Boolean(NaN); // false
const c6 = Boolean(0); // false
const c6 = Boolean(-0); // false
```

## 4.10-DeÄŸiÅŸken TÃ¼rÃ¼nÃ¼ Kontrol Etme

Ã‡alÄ±ÅŸtÄ±ÄŸÄ±mÄ±z veriler her zaman kodumuz iÃ§in uygun olmayabilir. Verilerin kontrolÃ¼nÃ¼ saÄŸlayÄ±p ona uygun kod yazabiliriz veya istediÄŸimiz tÃ¼re dÃ¶nÃ¼ÅŸtÃ¼rerek ilerleyebiliriz.

Bu kontrolleri yaparken sÄ±kÃ§a _typeof_ kullanÄ±lÄ±r.

```
console.log(typeof 42);
// beklenen output: "number"

console.log(typeof 'kodluyoruz');
//beklenen output: "string"

console.log(typeof true);
// beklenen output: "boolean"

console.log(typeof Variable);
// beklenen output: "undefined"
```

**Anahtar Notlar :**
Bir baÅŸka ÅŸekilde isInteger( ), isFinite( ) veya isNaN( ) kullanarak da kontrol saÄŸlayabiliriz.

```
//isInteger( ) yÃ¶ntemi, sayÄ±larÄ±n tam sayÄ± olup olmadÄ±ÄŸÄ±nÄ± belirler.
Number.isInteger(123) //true
Number.isInteger(-123) //true
Number.isInteger(0.5) //false
//isFinite () yÃ¶ntemi, bir deÄŸerin sonlu bir sayÄ± olup olmadÄ±ÄŸÄ±nÄ± belirler.
Number.isFinite(0) //true
Number.isFinite('123') //false
Number.isFinite('Hello') //false
Number.isFinite(-Infinity) //false
Number.isFinite(0 / 0) //false
// Number.isNaN () yÃ¶ntemi, bir deÄŸerin NaN (Not-A-Number) olup olmadÄ±ÄŸÄ±nÄ± belirler.

Number.isNaN(123) //false
Number.isNaN(0) //false
Number.isNaN('123') //false
Number.isNaN('Hello') //false
Number.isNaN('') //false
Number.isNaN(true) //false
Number.isNaN(undefined) //false
Number.isNaN('NaN') //false
Number.isNaN(NaN) //true
```

## 4.11-DeÄŸiÅŸken TÃ¼rÃ¼nÃ¼ DeÄŸiÅŸtirmek (Type Coercion)

Type Coercion; bir deÄŸiÅŸkenin tÃ¼rÃ¼nÃ¼, baÅŸka bir deÄŸiÅŸkene dÃ¶nÃ¼ÅŸtÃ¼rmeye yarayan yÃ¶ntemdir. Ä°ki tipi vardÄ±r. Bunlar explicit ve implicit dÃ¶nÃ¼ÅŸÃ¼mlerdir. Explicit iÃ§in metodlarla yapÄ±lan dÃ¶nÃ¼ÅŸÃ¼m denilebilir. Implicit ise operatÃ¶rler ile veya Javascript in kendi yaptÄ±ÄŸÄ± dÃ¶nÃ¼ÅŸÃ¼m diyebiliriz.

**Explicit Coercion**

```
String(123) // â€œ123â€
ParseInt(â€œ123â€) // 12
```

**Implicit Coercion**

```
If(3<5) // true
console.log(â€˜ â€™+123) // â€œ123â€
12/â€6â€ // 2
```

**String DÃ¶nÃ¼ÅŸÃ¼mÃ¼**

Bir deÄŸeri string e dÃ¶nÃ¼ÅŸtermek iÃ§in String() fonksiyonu kullanÄ±lÄ±r. Binary (kili) ifatede _+_ operatÃ¶rÃ¼ birstring ifadeye uygulandÄ±ÄŸÄ±nda ise implicit dÃ¶nÃ¼ÅŸÃ¼m tetiklenir.

```
String(123) // â€œ123â€ explicit
123 + ''    // â€œ123â€    implicit
```

**NOTLAR:**
Symbolâ€™de durum biraz farklÄ±dÄ±r, Ã§Ã¼nkÃ¼ dÃ¶nÃ¼ÅŸÃ¼m sadece explicit bir ÅŸekilde yapÄ±labilir, implicit bir ÅŸekilde yapÄ±lamaz.

```
String(Symbol('my symbol')) // 'Symbol(my symbol)'
'' + Symbol('my symbol') // TypeError is thrown
```

**Boolean DÃ¶nÃ¼ÅŸÃ¼mÃ¼**  
Bir deÄŸeri explicit boolean a dÃ¶nÃ¼ÅŸtÃ¼rmek iÃ§in Boolean() metodu kullanÄ±lÄ±r.  
Ä°mplicit coercion dÃ¶nÃ¼ÅŸÃ¼m ise mantÄ±ksal operatÃ¶rlerin kullanÄ±ldÄ±ÄŸÄ±nda tetiklenir.

```
Boolean(2) // explicit
var a=!!2 //explicit
if (2) { ... } // implicit due to logical context
!!2 // implicit due to logical operator
2 || 'hello' // implicit due to logical operator
```

**Ã–rekler**

```
Boolean('') // false
Boolean(0) // false
Boolean(-0) // false
Boolean(NaN) // false
Boolean(null) // false
Boolean(undefined) // false
Boolean(false) // false

Boolean({}) // true
Boolean([]) // true
Boolean(Symbol()) // true
!!Symbol() // true
Boolean(function() {}) // true
```

**Nesneler (Objects) iÃ§in Type Coercion**
Javascript te nesneler referans tipler olduÄŸundan Ã¼zerlerinde deÄŸiÅŸiklik yapmak biraz zordur. DeÄŸiÅŸiklik yapabilmemiz iÃ§in elimizde primitif tip olmasÄ± gerekir. Yani referans tipler primitif tiplere zorlanÄ±r. Primitif olmayan herhangi bir deÄŸer yada obje (object veya array) dolu yada boÅŸ farketmez true deÄŸere dÃ¶necektir.

```
console.log(Boolean({})) // true
console.log(Boolean([])) // true
console.log(Boolean([1,2,3])) // true
console.log(Boolean({13:234})) //true
```

## 4.12-Template Literals KullanÄ±mÄ±

Template literals (Ã¶neki adÄ± template Strings), kod okunabilirliÄŸi ve yazÄ±m kolaylÄ±ÄŸÄ± saÄŸlayan ES6 ile gelmiÅŸ bir string yazma ÅŸeklidir.

**SaÄŸladÄ±ÄŸÄ± faydalar**

- Ã‡ok satÄ±rlÄ± dize yazÄ±mÄ±

```
//Eski kullanÄ±m:
let eskiString = "En sevdiÄŸim yemekler:\nÄ°skender\nMantÄ±"

//Yeni kullanÄ±m:
let yeniString = `En sevdiÄŸim yemekler:
Ä°skender
MantÄ±`
```

- Ä°nterpolasyon : metin iÃ§erisinde deÄŸiÅŸken kullanmak anlamÄ±na gelir.

```
let ad= `Ziya`;
let soyad= `Ã‡AYLAN`;

//Eski kullanÄ±m
console.log("Benim adÄ±m "+ad+" "+ soyad);

//Yeni kullanÄ±m
console.log(`Benim adÄ±m ${ad} ${soyad}`);
```

- Html ÅablonlarÄ± : Ã‡ok satÄ±rlÄ± dizeleri kolaylÄ±kla kullanmak ve dizelerimize iÃ§erik eklemek iÃ§in de Template Literalâ€™den faydalanabiliriz.

```
//DeÄŸiÅŸkenlerimizi tanÄ±mlayalÄ±m
const ad =`Ziya`
const soyad =`Ã‡AYLAN`
const gozRengi =`Kahverengi`
const yas =39


const kisi = `
<p>${ad}</>
<p>${soyad}</>
<p>${gozRengi}</>
<p>${yas}</>
`;

document.body.innerHTML = kisi;

//Bu kullanÄ±m daha az karmaÅŸÄ±k ve okunabilir.
```

**KÄ±saca FaydalarÄ±nÄ± sÄ±ralarsak**

- Kod okunabilirliÄŸini kolaylaÅŸtÄ±rÄ±r
- String ifadeler iÃ§erisinde deÄŸiÅŸken yazma kolaylÄ±ÄŸÄ± saÄŸlar,
- Åablon etiketlerini daha karmaÅŸÄ±k hale getirir.

[Linkteki Ã¶rneÄŸi inceleyiniz.](./Javascript-Dersleri/template-literal-example/template-literal.js). Ã–rnekte template literal kullanÄ±larak web sayfasÄ±nda kitaplar listelenmiÅŸtir.

## 4.13-String Veri TÃ¼rÃ¼ Ä°ÅŸlemleri

**String nedir ?**

Javascript e metinlerin tÃ¼mÃ¼ _string_ veri tipinde tutulur.

**Length Ã–zelliÄŸi**

String ifadenin uzunluÄŸunu bize verir. AÅŸaÄŸÄ±daki Ã¶rneÄŸi inceleyiniz.

```
const str = "javascript";
// bu ifadenin sonucu konsol ekranÄ±nda 10 olarak gÃ¶rÃ¼ntÃ¼lenecektir.
console.log(str.length);
```

**indexOf Ã–zelliÄŸi**

Metin iÃ§erisinde arama yapmak istediÄŸimizde bize aradÄ±ÄŸÄ±mÄ±z deÄŸerin index numarasÄ±nÄ± verir.

```
const str = "Ziya Ã§aylan";
// 'ya' nÄ±n baÅŸladÄ±ÄŸÄ± index numarasÄ±nÄ± geri dÃ¶ner yani 2
console.log(str.indexOf("ya"));
```

**lastIndexOf Ã–zelliÄŸi**

indexOf ile aynÄ± Ã§alÄ±ÅŸÄ±r ancak arasÄ±ndaki fark; metin iÃ§erisinde arama yapmak istediÄŸimizde aradÄ±ÄŸÄ±mÄ±z deÄŸerin en son karÅŸÄ±laÅŸtÄ±ÄŸÄ± index numarasÄ±nÄ± geri dÃ¶ner. AÅŸaÄŸÄ±daki Ã¶rnekte olduÄŸu gibi

```
const str = "Ziya Ã§aylan";
// 'a' nÄ±n en son gÃ¶rÃ¼ldÃ¼ÄŸÃ¼ index numarasÄ±nÄ± geri dÃ¶ner yani 9
console.log(str.indexOf("a"));
```

**Search - Metin Ä°Ã§erisinde Arama Yapma**

indexOf ile aynÄ± ÅŸekilde Ã§alÄ±ÅŸÄ±r ve _"Regular Expressions"_ iÅŸlemlerinde Ã§ok kullanÄ±lmaktadÄ±r.

```
const str = "Ziya Ã§aylan";
// 'ya' index numarasÄ±nÄ± geri dÃ¶ner yani 2
console.log(
  `Search ile "ya" yÄ± aradÄ±ÄŸÄ±mÄ±zda geri dÃ¶nen deÄŸer ${str.search("ya")}`  // konsolda : Search ile "ya" yÄ± aradÄ±ÄŸÄ±mÄ±zda geri dÃ¶nen deÄŸer 2
);
```

**Slice - Metinden ParÃ§a Alma**

- Bu metod ile metinden bir parÃ§a almak istediÄŸimizde almak istediÄŸimiz yerin index numarasÄ±nÄ± vererek alabiliriz.

```
const str = "Ziya Ã§aylan";

console.log(str.slice(2, 4)); // 2. index numarasÄ±ndan baÅŸlar ve 4. index numarasÄ±na kadar alÄ±r ancak 4. index dahil deÄŸildir.
```

- slice metoduna tek parametre verdiÄŸimizde ise; verdiÄŸimiz parametreden baÅŸlar ve metinin sununa kadar alÄ±r

```
const str = "Ziya Ã§aylan";

console.log(str.slice(2)); // 2. index numarasÄ±ndan baÅŸlar ve sona kadar alÄ±r Konsolda : ya Ã§aylan
```

- index numarasÄ± hiÃ§ yazmaz isek metini komple alÄ±r.

**Replace - Metodu (Metin bulma ve deÄŸiÅŸtirme)**

AradÄ±ÄŸÄ±mz metini bulmamÄ±zÄ± ve istediÄŸimiz metin ile deÄŸiÅŸtirmemizi saÄŸlar.

```
const str = "Ziya Ã§aylan";

console.log(str.replace("Ã§aylan", "Ã‡AYLAN")); // ""Ã§aylan metinini bulur ver onun yerine "Ã‡AYLAN" yazar
```

**toUpperCase ve toLowerCase**

- toUpperCase ile metin bÃ¼yÃ¼k harfe Ã§evrilir.
- toLowerCase ile de metin tamamÄ± kÃ¼Ã§Ã¼k harfe Ã§evrilir.

```
const str = "Ziya Ã§aylan";

console.log(str.toUpperCase()); // ZIYA Ã‡AYLAN
console.log(str.toLocaleLowerCase()); // ziya Ã§aylan
```

**Concat - Metin BirleÅŸtirme**

- Elimizdeki iki string tÃ¼rÃ¼nden veriyi birleÅŸtirmemize olanak saÄŸlar

```
const myName = "ziya";
const surname = "Ã§aylan";

console.log(myName.concat(" ", surname)); //myName den sonra belirttiÄŸimiz gibi " " (bir boÅŸluk bÄ±rakÄ±r ve surname i ekler) konsolda : ziya Ã§aylan
```

**charAt- Ä°ndex NumarasÄ±na GÃ¶re Karakter Bulmak**

- BelirttiÄŸimiz index numarasÄ±ndaki karakteri geri dÃ¶ndÃ¼rÃ¼r.

```
const str = "Ziya Ã§aylan";

console.log(str.charAt(2)); // y
console.log(str.charAt(3)); // a
```

**charCodeAt â€“ Ä°ndex NumarasÄ±na GÃ¶re Karakterin Unicode DeÄŸerini Bulma**

- BelirttiÄŸimiz index numarasÄ±ndaki karakterin Unicode deÄŸerini geri dÃ¶ndÃ¼rÃ¼r.

```
const str = "Ziya Ã§aylan";

console.log(str.charCodeAt(2)); // 121
```

**Split â€“ Metni Diziye Ã‡evirme**

- splite metodu ile metin diziye Ã§evrilebilir.
- KullanÄ±lan parametre ile de metinin nasÄ±l parÃ§alanacaÄŸÄ± belirlenir.

```
const str = "Ziya Ã§aylan";

const isimler = str.split(" ");
console.log(isimler); // [ 'Ziya', 'Ã§aylan' ]

const metin = "ziya-ali-veli-hasan-hÃ¼seyin-mehmet-mahmut-canan-caner-eda-seda";
console.log(metin.split("-")); // ['ziya','ali','veli','hasan','hÃ¼seyin','mehmet','mahmut','canan','caner','eda','seda']
```

[Linkteki string Ã¶rneklerini inceleyiniz.](./Javascript-Dersleri/string-ozellikleri/string.js).

**BazÄ± Ã–rnekler**

```
// istenilen karakterden sonrasÄ±nÄ± alma
// Ã–rnek --> ziyacaylan@gmail.com
// '@' iÅŸaretinden sonraki karakterleri alma

const email = "ziyacaylan@gmail.com";

const domain = email.slice(email.search("@") + 1);
console.log(domain);  // gmail.com

const userName = email.slice(0, email.search("@"));
console.log(userName);  // ziyacaylan
```

## 4.14-Document Object Model (DOM) Nedir ?

- 3C (World Wide Web Consortium) a gÃ¶re DOM programlarÄ±n ve komut dosyalarÄ±nÄ±n bir belge iÃ§eriÄŸine yapÄ±sÄ±na ve stiline dinamik olarak eriÅŸmesine ve gÃ¼ncellemesine izin veren bir platform ve dilden baÄŸÄ±msÄ±z bir arayÃ¼zdÃ¼r.
- HTML yapÄ±sÄ±nÄ± daha Ã¶nce incelemiÅŸtik. TarayÄ±cÄ±nÄ±n belgeyi temsil etmek iÃ§in kullandÄ±ÄŸÄ± veri yapÄ±sÄ± bu ÅŸekli izler.Her kutu iÃ§in, hangi HTML etiketini temsil ettiÄŸi ve hangi kutularÄ± ve metni iÃ§erdiÄŸi gibi ÅŸeyleri bulmak iÃ§in etkileÅŸime girebileceÄŸimiz bir nesne vardÄ±r. Bu temsil, **Document Object Model** veya kÄ±saca **DOM** olarak adlandÄ±rÄ±lÄ±r.
- DOM bir aÄŸaÃ§ dizini gibi bÃ¼tÃ¼n dokÃ¼manlarÄ± birbirine baÄŸlar.  
  ![DOM](./Javascript-Dersleri/assets/dom.jpg)

  [Linkteki Ã¶rnekleri inceleyiniz.](./Javascript-Dersleri/dom/index.html)

**DOM iÃ§erisinden Etiket ve ID ile Ã–ÄŸe SeÃ§imi**

- document objesinin getElemntById() metodu kullanÄ±larak sayfadaki html elementlerinin ID leri referans alÄ±narak seÃ§im iÅŸlemi yapÄ±labilir.
- ID'ler bÃ¼yÃ¼k-kÃ¼Ã§Ã¼k harf duyarlÄ±dÄ±r. Bu sayede HTML document iÃ§inde biriciklik gÃ¶sterir ve her zaman geriye bir eleman dÃ¶ndÃ¼rÃ¼r. Bir eÅŸleÅŸme bulamazsa da geriye _null_ dÃ¶nÃ¼ÅŸÃ¼nÃ¼ yapar.

```
document.getElementById('#root'); // null
document.getElementById('root'); // <section id=â€‹"root">â€‹â€¦â€‹</section>â€‹
```

**Get Elements By Tag Name**

- ElemanlarÄ± etiket isimlerine gÃ¶re seÃ§mek iÃ§in document objesinin _getElemntByTagName()_ metodu kullanÄ±lÄ±r.
- Genelde birden Ã§ok elemana ulaÅŸmak iÃ§in kullanÄ±lÄ±r.
- Girdi olarak bir _html elementi_ alÄ±r ve geriye bir _HTMLCollection_ dÃ¶ndÃ¼rÃ¼r.

**Get Elements By Name**

- ElemanlarÄ± isimleri gÃ¶re getirmek iÃ§in document objesinin _getElementByName()_ metodu kullanÄ±lÄ±r.
- ElemanlarÄ± name deÄŸerlerine gÃ¶re bir _NodeList objesi_ dÃ¶ndÃ¼rÃ¼r.

```
<input type="text" name="e-posta">
<input type="tel" name="telefon">
<input type="date" name="tarih">
```

telefon adÄ±nÄ± taÅŸÄ±yan elemanlarÄ± getirelim

```
const tel = document.getElementsByName('telefon');
console.log(tel) // NodeListÂ [input]
```

**Get Elements By Class Name**

- DOM da istediÄŸimiz class name e sahip olan elementleri seÃ§mek iÃ§in _getElemntByClassName()_ metodu kullanÄ±lÄ±r.
- Bu metodda bize HTMLCollection dÃ¶ndÃ¼rÃ¼r.
- KullanÄ±rken class name baÅŸÄ±na **nokta** _"."_ koymalÄ±yÄ±z.

```
    <div class="baykuÅŸ kusu">ğŸ¦‰</div>
    <div class="guvercin kusu">ğŸ¦</div>
    <div class="kartal kusu">ğŸ¦…</div>
    <div class="kedi">ğŸ±</div>
```

```
    //Get Elements By Class Name
    const kuslar = document.getElementsByClassName("kusu");
    console.log(kuslar); // HTMLCollection(3)Â [div.baykuÅŸ.kusu, div.guvercin.kusu, div.kartal.kusu]
```

**Query Selector**

- QuerySelector () yÃ¶ntemi, css seÃ§icilere baÄŸlÄ± olarak DOM da html elemanlarÄ±nÄ± seÃ§memize olanak saÄŸlayan iki modern javascript yÃ¶nteminden biridir.
- Bu yÃ¶ntem ile elementlerin hem class larÄ±nÄ± hemde id lerini kullanabiliriz.
- Bunu yaparken classlarÄ±n Ã¶nÃ¼ne "." id lerin Ã¶nÃ¼ne ise "#" kullanmamÄ±z gerekir.
- Sayfada ilk eÅŸleÅŸen eleman Ä± geriye dÃ¶ndÃ¼rÃ¼r.
- Belirtilen eleman ile eÅŸleÅŸmez ise geriye _null_ dÃ¶necektir.

**Query Selector All**

- querySelectorAll() metodu, QuerySelector () metodu ile aynÄ± mantÄ±k ile Ã§alÄ±ÅŸÄ±r tek farkÄ± eÅŸleÅŸen ilk elamanÄ± dÃ¶ndÃ¼rmek yerine eÅŸleÅŸen tÃ¼m elemanlarÄ± bir NodeList objesi olarak dÃ¶ndÃ¼rmesidir.

**Prompt ile KullanÄ±cÄ±dan bilgi alma**

- javascript te kullanÄ±cÄ±dan bilgi almak iÃ§in kullanÄ±lÄ±r.
- alÄ±nan bilgi bir deÄŸiÅŸkene atanabilir; sÃ¶zdizimi ÅŸu ÅŸekilde olacaktÄ±r: const _kelime = prompt("LÃ¼tfen bir kelime yazÄ±nÄ±z :");_

```
<div id="isim">Benim AdÄ±m :</div>
```

yukarÄ±daki html koduna javascript dosyamÄ±zdan ulaÅŸarak bir isim girelim

```
/*prompt () kullanÄ±mÄ± */
let myName = prompt("LÃ¼tfen adÄ±nÄ±zÄ± yazÄ±nÄ±z :");
let isim = document.querySelector("#isim");

isim.innerHTML = `${isim.innerHTML} <strong style = "color : blue;"
>${myName}</strong>`;
```

Prompt mantÄ±ÄŸÄ± ÅŸu ÅŸekildedir.

- KullanÄ±cÄ± **Tamam** dÃ¼ÄŸmesine tÄ±kladÄ±ÄŸÄ±nda geriye girilen deÄŸer dÃ¶ndÃ¼rÃ¼lÃ¼r.
- Herhangi bir metin girmeden **Tamam** dÃ¼ÄŸmesine tÄ±klanÄ±r ise geriye boÅŸ bir dize dÃ¶ner.
- KullanÄ±cÄ± **Ä°ptal** dÃ¼ÄŸmesine tÄ±klar ise iÅŸlev boÅŸ dÃ¶ndÃ¼rÃ¼r.

**DOM'a CSS Class Bilgisi Eklemek veya Ã‡Ä±karmak**

- Javascript te css sÄ±nÄ±flarÄ±na manipÃ¼le etmenin en iy i yollarÄ±ndan birisi **classList** kullanmaktÄ±r.
- **classList** bir Ã¶ÄŸenin sÄ±nÄ±f isimlerini **DOMTokenList** olarak dÃ¶ndÃ¼rÃ¼r.
- **classList** Ã¶zelliÄŸi bÃ¼tÃ¼n modern browserlarda Ã§alÄ±ÅŸmaktadÄ±r.

```
<head>
<title>Dome Example</title>
    <style>
      .text-primary {
        color: blue;
      }
      .btn {
        display: inline-block;
        border: none;
        width: auto;
        height: 2rem;
        border-radius: 0.4rem;
      }
      .btn-primary {
        background-color: blue;
      }
      .text-white {
        color: white;
      }
      .text-secondary {
        color: darkviolet;
      }
    </style>
  </head>
  <body>
    <h1 id="baslik">Frontend Dersleri / Javascript / DOM</h1>
    <button id="btn" class="btn">Benim Butonum</button>

    <script src="./class-elkeme.js"></script>
  </body>
```

YukarÄ±daki html sayfasÄ±na ulaÅŸarak class isimlere ulaÅŸÄ±p ekleme ve class silme iÅŸlemlerini deneyelim.

```
/*Listeye ulaÅŸmak ve eleman eklemek veya elemanÄ± deÄŸiÅŸtirmek */

let lastItem = document.querySelector("ul#list>li:last-child");

//console.log(lastItem);

lastItem.innerHTML = "Son Ã¶ÄŸeye ulaÅŸÄ±ldÄ± ve deÄŸiÅŸtirildi";

// ilk Ã¶ÄŸeye ulaÅŸmak
let firstItem = document.querySelector("ul#list>li:first-child");

firstItem.innerHTML = "Ä°lk Ã¶ÄŸeye ulaÅŸÄ±ldÄ± ve deÄŸiÅŸtirildi.";

// listeye yeni bir Ã¶ÄŸe eklemek

let ulList = document.querySelector("ul#list");

let newItem = document.createElement("li");

newItem.innerHTML = "Yeni eleman eklendi";

ulList.append(newItem); // son eleman olarak ekleme yapar

ulList.prepend(newItem); // ilk eleman olarak ekler
```

**Properties**

- **add() :** HTML Ã¶ÄŸerise bir veya daha fazla class eklemek iÃ§in kullanÄ±lÄ±r.
- **remove() :** HTML Ã¶ÄŸesinden bir veya daha fazla class silmek iÃ§in kullanÄ±lÄ±r.
- **item() :** HTML de class'Ä± verilen index sÄ±rasÄ±na gÃ¶re dÃ¶ndÃ¼rÃ¼r. EÄŸer index, class length'inden (sayÄ±sÄ±ndan) daha bÃ¼yÃ¼k veya length'ine eÅŸit olursa undefined dÃ¶ner.
- **contains() :** HTML Ã¶ÄŸesinin verilen class ismini iÃ§eriyorsa _true_ iÃ§ermiyorsa _false_ dÃ¶ner. Bu sayede iÅŸlem yaptÄ±rmadan Ã¶nce kontrol saÄŸlamÄ±ÅŸ oluruz.
- **toggle() :** _classList.add()_ ve _classList.remove()_ yÃ¶ntemini aynÄ± anda Ã§aÄŸÄ±rmak yerine _classList.toggle()_ yÃ¶ntemini kullanÄ±labilir.
  **Anahtar NOT :** Bu metodu kullanmadan Ã¶nce contains() metodu ile sÄ±nÄ±fÄ±n var olup olmadÄ±ÄŸÄ±nÄ± manuel olarak kontrol etmek gerekir.
- **replace() :** Bir css classÄ±nÄ± baÅŸka bir sÄ±nÄ±f ile deÄŸiÅŸtirmek iÃ§in kullanÄ±lÄ±r.
- **length() :** Bir Ã¶ÄŸenin sahip olduÄŸu sÄ±nÄ±f sayÄ±sÄ±nÄ± bulmak iÃ§in kullanÄ±lÄ±r.

## 4.15-KarÅŸÄ±laÅŸtÄ±rma OperatÃ¶rleri ve MantÄ±ksal OperatÃ¶rler

### KarÅŸÄ±laÅŸtÄ±rma OperatÃ¶rleri

- **== EÅŸitse** OperatÃ¶rÃ¼ :

```
const a = 10;
const b = "10";
console.log(a == b); // true
```

- **=== Hem deÄŸeri hem de tÃ¼rÃ¼ eÅŸit ise** OperatÃ¶ri

```
/*=== Hem deÄŸeri hem de tÃ¼rÃ¼ eÅŸit ise */
const a = 10;
const b = "10";

console.log(a === b); // false -> DeÄŸeri eÅŸit fakat tÃ¼rÃ¼ farklÄ± olduÄŸundan false
```

- **!= EÅŸit deÄŸilse** OperatÃ¶rÃ¼

```
const a = 10;
const b = "10";

/*!= EÅŸit deÄŸilse */

console.log(a != b); // deÄŸerleri eÅŸit fakat deÄŸili false

console.log(a !== b); // deÄŸeri eÅŸit fakat tÃ¼rÃ¼ farklÄ± ancak deÄŸili true
```

- **< KÃ¼Ã§Ã¼kse** ve **<= KÃ¼Ã§Ã¼k veya eÅŸitse** OperatÃ¶rleri

```
const a = 10;
const b = 10;

/*< KÃ¼Ã§Ã¼kse */
console.log(a < b); // false

/*<= KÃ¼Ã§Ã¼k veya eÅŸitse */
console.log(a <= b); // true
```

- **> BÃ¼yÃ¼kse** ve **>= BÃ¼yÃ¼k veya eÅŸitse** OperatÃ¶rleri

```
const a = 10;
const b = 10;

/* > BÃ¼yÃ¼kse ve >= BÃ¼yÃ¼k veya eÅŸitse */

console.log(a > b); // false

console.log(a >= b); // true
```

### MantÄ±ksal OperatÃ¶rler

MantÄ±ksal operatÃ¶rler ile birden fazla koÅŸula gÃ¶re karÅŸÄ±laÅŸtÄ±ma yapabiliriz. KarÅŸÄ±laÅŸtÄ±rma sonucunda _true_ yada _false_ deÄŸeri dÃ¶ner

- **&& ve**

```
const a = 10;
const b = 10;
constc = 20;

//&& ve
console.log(`&& ve : ${a === b && a < c}`); // true
```

- **|| veya**

```
const a = 10;
const b = 10;
constc = 20;

// || veya
console.log(`|| veya : ${a === b || a > c}`); // true
```

- **! deÄŸil**

```
const a = 10;
const b = 10;
constc = 20;

// "! deÄŸil"
console.log(`! deÄŸili : ${!(a === b || a > c)}`); // false
```

## 4.16-if / else (koÅŸul yapÄ±sÄ±) KullanÄ±mÄ±

- If else yapÄ±sÄ± iÃ§erisinde koÅŸulun saÄŸlandÄ±ÄŸÄ± kodlar if iÃ§erisinde yer alÄ±rken, koÅŸulun saÄŸlanmadÄ±ÄŸÄ± kodlar ise else iÃ§erisinde yer alÄ±r.
- EÄŸer ilk koÅŸul yanlÄ±ÅŸsa baÅŸka bir koÅŸul belirtmek amacÄ±yla else if kullanÄ±lÄ±r.

```
if(kosul) {
    // Bu kod satÄ±rÄ± Ã§alÄ±ÅŸacaktÄ±r.
}

else {
    // Bu kod satÄ±rÄ± Ã§alÄ±ÅŸÄ±r.
}
```

**Ã‡ALIÅMA SORUSU**

- Bilgisayar tarafÄ±ndan 1-10 arasÄ± belirlenen bir sayÄ±yÄ±, kullanÄ±cÄ±dan klavye ile girilen bir sayÄ± ile hatmin edilmeye Ã§alÄ±ÅŸÄ±lan yapÄ±yÄ± kurgulayarak yazÄ±nÄ±z.
- web sayfasÄ± Ã¼zerinde girilen sayÄ±, tahmin edilen sayÄ± ve sonuca gÃ¶re doÄŸru yada yanlÄ±ÅŸ olduÄŸunu belirtiniz.

**_CEVAP_**  
 [Linkten Ã§alÄ±ÅŸma dosyasÄ±na ulaÅŸarak inceleyiniz.](./Javascript-Dersleri/Karar-Yapilari-ve-Kosullar/karsilastirma-operatorleri-ve-mantiksal-operatorler/karsilastirma-operatorleri.js)  
[index.html sayfa linki](./Javascript-Dersleri/Karar-Yapilari-ve-Kosullar/index.html)

## 4.17-switch (Ã§oklu koÅŸul yapÄ±sÄ±) KullanÄ±mÄ±

Javascriptte if-else yapÄ±sÄ±nda koÅŸul sayÄ±sÄ±nÄ±n arttÄ±ÄŸÄ± durumlarda kod okunurluÄŸunu arrÄ±tmak ve daha performanslÄ± sayÄ±labilecek bir yapÄ± olan _switch_ kullanÄ±lÄ±r.

**Syntax**

```
switch(ifade) {
  case a:
    // kod bloÄŸu
    break;
  case b:
    // kod bloÄŸu
    break;
  default:
    // kod bloÄŸu
}
```

**Ã–RNEK**

```
let hava = "Gunesli";
switch(hava) {
  case "Yagmurlu":
      console.log("Semsiyeni yanina almayi unutma");
      break;
  case "Gunesli":
      console.log("Hafif giyin");
  case "Bulutlu":
      console.log("Disari cik");
      break;
  case "KarlÄ±":
      console.log("Kalin giyin");
      break;
  case "Firtinali":
      console.log("Bir sÃ¼re disari cikma");
      break;
  default:
      console.log("Bilinmeyen hava durumu:" , hava);
}
```

AÅŸaÄŸÄ±da switch akÄ±ÅŸ diyagramÄ± Ã¶rnek olarak verilmiÅŸtir ve nasÄ±l Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± inceleyebilirsiniz...  
![switch-case](./Javascript-Dersleri/assets/switch-case.jpg)

## 4.18- Ternary OperatÃ¶rÃ¼

- **Ternary Operator** 3 adet parametre alan tekJavascript operatÃ¶rÃ¼dÃ¼r
- _If_ kullanarak kontrol etmek istediÄŸimiz koÅŸullarda _ternary operator_ kullanarak satÄ±r sayÄ±sÄ± olarak avantaj saÄŸlayabiliriz.

**Ternary operatÃ¶rÃ¼nÃ¼n aldÄ±ÄŸÄ± 3 parametre ÅŸu ÅŸekildedir:**

- Ä°lk Ã¶nce bir condition belirtiriz ve sonra _?_ koyarÄ±z
- Sonra yazdÄ±ÄŸÄ±mÄ±z condition doÄŸru ise ne yapmak istediÄŸimizi yazarÄ±z ve sonuna _:_ koyarÄ±z
- Ve son olarakda condition false ise ne yapmak istediÄŸimizi yazarÄ±z.

**Anahtar NOT:**
Ternary operatÃ¶rleri aynÄ± zamanda birbiri ardÄ±na zincirleyerek (chaining) kullanabiliriz. Bu sayede farklÄ± olasÄ±lÄ±klarÄ± da katarak daha detaylÄ± senaryolarÄ± kontrol edebiliriz.

```
const para = 40;
const satinAlma =
    (para < 17) ? "SatÄ±n alamazsÄ±n..":
    (para > 30) ? "SatÄ±n alabilirsin..":
    "Para miktarÄ±nÄ± girmen gerekmektedir..";

console.log(satinAlma) // "SatÄ±n alabilirsin.."
```

## 4.19- Fonksiyon Nedir? Neden KullanÄ±rÄ±z?

Fonksiyon bir iÅŸlevi yerine getirmek iÃ§in tasarlanmÄ±ÅŸ kod bloklarÄ±dÄ±r. KodlaerÄ±mÄ±za iÅŸlevsellik katmak iÃ§in sÄ±k sÄ±k kullanÄ±rÄ±z.

**Fonksiyon AdlandÄ±rma Fonksiyon Bildirimi(Function Declaration)**

- ilk olarak _function_ ibaresi yazÄ±lÄ±r ve sonra fonksiyonun ismi yazÄ±lÄ±r.
- fonksiyon isimleri belirlenirken bir eylem bildiren isimler kullanÄ±lmalÄ±dÄ±r. Fonksiyon isimleri bazÄ± Ã¶n ekler alabilirler.
- Ã–rneÄŸin bir deÄŸer almak istediÄŸimizde **_get_**, bir deÄŸeri deÄŸiÅŸtirmek istediÄŸimizde **_set_** yada duÄŸru yada yanlÄ±ÅŸ (true-false) gibi bir sonuÃ§ almak istediÄŸimizde ise **_is_** Ã¶n eki eklenebilir.
- Bununla birlikte ÅŸunu da unutmamalÄ±yÄ±z istendiÄŸinde adÄ± olmayan anonim bir fonksiyon da kullanÄ±labilir. AÅŸaÄŸÄ±da bu fonksiyon tÃ¼rÃ¼nden bahsediliyor

- fonksiyon isminden sonra parantezler iÃ§erisinde parametreler verilir. Parametre girmek zorunlu olmadÄ±ÄŸÄ± gibi fazla parametre girmek de kodun okunurluÄŸunu bozabilir.
- parametre alan bu fonksiyonlarÄ± kullandÄ±ÄŸÄ±mÄ±zda parametrelere kendmiz deÄŸer atarÄ±z. Atanan bu deÄŸerlere **_argÃ¼man_** adÄ± verilir.
- fonksiyon isimleri kÃ¼Ã§Ã¼k harf ile baÅŸlanmalÄ± ve iki kelimenin yada daha fazla kelimenin birleÅŸimi ile sonradan gelen kelimeler arasÄ±nda boÅŸluk v.b. kullanÄ±lmamalÄ± ve ilk kelimeden sonraki kelimenin baÅŸ harfleri bÃ¼yÃ¼k yazÄ±lmalÄ±dÄ±r.
- fonksiyon ismi ve var ise parantezler arasÄ±nda parametreler verildikten sonra parantez kapatÄ±lÄ±r ve sÃ¼slÃ¼ parantezler aÃ§Ä±larak javascript kodlarÄ± eklenir. Bu sÃ¼slÃ¼ parantezler arasÄ±ndaki kÄ±sÄ±m _fonksiyonun gÃ¶vdesi_ denir.

```
function printHello(name) {
  console.log("Merhaba " + name);
}

printHello("Ziya");  // Merhaba Ziya
```

**Anahtar NOTLAR:**

- Fonksiyonun tanÄ±mÄ± bir **_statement_** dÄ±r. (geriye deÄŸer dÃ¶ndÃ¼rmez.)
- Ancak yazÄ±lan fonksiyon Ã§alÄ±ÅŸtÄ±rÄ±lÄ±r ise **return** kullanmasa bile geriye deÄŸer dÃ¶ndÃ¼rÃ¼r Buna **_expression_** denir

**_Anonymous Functions_**
Bazen fonksiyonlara isim vermeden de kullanÄ±lÄ±r. Bunlar anonymous fonksiyonlardÄ±r. anonymous fonksiyonlarÄ±n bir isimi yoktur ve bir deÄŸiÅŸkene atanarak kullanÄ±lÄ±rlar.
DeÄŸiÅŸken adÄ± kullanÄ±larak Ã§aÄŸrÄ±ldÄ±klarÄ± iÃ§in birden Ã§ok anonim fonksiyonu aynÄ± dizide kullanabilirsiniz.DahasÄ± bir deÄŸiÅŸkene atandÄ±klarÄ±ndan bu deÄŸiÅŸkeni baÅŸka bir fonksiyonun parametresine koyarak **_callback_** (geri arama) yapabilirsiniz.

```
function addition(sayi1,sayi2){  //function name and parameters
        console.log(sayi1+sayi2);     //body
}
```

```
const add = function (sayi1,sayi2){  //Anonim bir fonksiyon oluÅŸturduktan sonra bu
                                   //fonsksiyonu bir deÄŸiÅŸkene atadÄ±k
        console.log(sayi1+sayi2);
}
```

**DeÄŸer DÃ¶ndÃ¼ren Fonksiyonlar**

- Bazen fonksiyondan geriye deÄŸer dÃ¶ndÃ¼rÃ¼p bunu da baÅŸka iÅŸlemler iÃ§in kullanÄ±r yada baÅŸka bir fonksiyona parametre olarak verebiliriz.
- BÃ¶yle durumlarda **_return_** ifadesi kullanÄ±larak geriye deÄŸer dÃ¶ndÃ¼rÃ¼lÃ¼r.

```
function sum(number1,number2){
return (number1+number2);
}
const add = sum(5,10); // 15
```

**Fonksiyon KapsamÄ±**

- Javascriptte fonksiyon iÃ§erisinde tanÄ±mlanmÄ±ÅŸ olan deÄŸiÅŸkene dÄ±ÅŸarÄ±daki herhangi bir yerden eriÅŸilemez.
- TanÄ±mlanan deÄŸiÅŸken **_fonksiyon kapsamÄ±ndadÄ±r._**
- Fonksiyon iÃ§erisinde kullanÄ±lan deÄŸiÅŸken **_lokal deÄŸiÅŸken_** adÄ± verilir.
- Ancak fonksiyon tanÄ±mlandÄ±ÄŸÄ± anda, tanÄ±mlandÄ±ÄŸÄ± kapsamdaki **_global deÄŸiÅŸkenlere_** eriÅŸebilir.

```
const number1 = 3;
const number2 = 5;

function sum(sayi1,sayi2){
    let sayi3 = 0; /sayi3 adÄ±nda lokal bir deÄŸiÅŸken tanÄ±mlÄ±yoruz
    return sayi1+sayi2+sayi3;  //Fonksiyon iÃ§inde global ve local deÄŸiÅŸkenleri kullanÄ±yoruz
}

function multiSum (){
    return number1 + number2 + sayi3; // error
}

```

**Callback Fonksiyonlar ve Asenkron Ã‡alÄ±ÅŸma**

- javascriptte kodumuz yukarÄ±dan aÅŸaÄŸÄ±ya doÄŸru okunur ve bir Ã¶nceki satÄ±r bitmeden bir sonrakine geÃ§ilmez. Buna **_senkron Ã§alÄ±ÅŸma_** denir.
- asenkron Ã§alÄ±ÅŸmada ise fonksiyonlarÄ±n birbirlerini beklemelerine gerek yoktur.
- javascript asenkron yapÄ±daki bir programlama dilidir.
  AÅŸaÄŸÄ±daki Ã¶rneÄŸi inceleyip anlamaya Ã§alÄ±ÅŸalÄ±m:

```
const func1 = () => console.log("ilk fonksiyon Ã§alÄ±ÅŸtÄ±");

const func2 = () => {
  setTimeout(() => console.log("ikinci fonksiyon Ã§alÄ±ÅŸtÄ±"), 3000);
};

const func3 = () => {
  setTimeout(() => console.log("Ã¼Ã§Ã¼ncÃ¼ fonksiyon Ã§alÄ±ÅŸtÄ±"), 2000);
};

func1();
func2();
func3();
```

YukarÄ±daki programda sÄ±rasÄ±yla fonksiyonlar Ã§aÄŸÄ±rÄ±lmÄ±ÅŸtÄ±r. Ancak ekran Ã§Ä±ktÄ±sÄ± aÅŸaÄŸÄ±daki ÅŸekilde olacaktÄ±r.

ilk fonksiyon Ã§alÄ±ÅŸtÄ±  
Ã¼Ã§Ã¼ncÃ¼ fonksiyon Ã§alÄ±ÅŸtÄ±  
ikinci fonksiyon Ã§alÄ±ÅŸtÄ±

**Fonksiyon Ä°fadeleri (Function Expressions)**

- Javascript bir deÄŸiÅŸkene fonksiyon atamaya ve daha sonra bunu fonksiyon olarak kullanmaya izin verir.

**Arrow Functions**

- Bu yÃ¶ntem ile fonksiyon oluÅŸturma ES6 ile birlikte gelmiÅŸtir.
- Daha okunabilir bir syntax yapÄ±sÄ±na sahiptir.

```
const func1 = function (param1,param1){
  return param1 + param2;
}
```

YukarÄ±da normal fonksiyonun arrow fonksiyon karÅŸÄ±lÄ±ÄŸÄ± aÅŸaÄŸÄ±daki gibidir.

```
const func1 =(param1, param2) => param1 + param2;
```

- Arrow fonksiyon **_syntax_** yazÄ±lÄ±rken parametrelerden sonra kod bloÄŸu yazÄ±lÄ±rken sadece tek bir kod Ã§alÄ±ÅŸtÄ±rÄ±lacaksa sÃ¼slÃ¼ parantezlerin yazÄ±lmasÄ±na ve de **_return_** bildiriminin yapÄ±lmasÄ±na gerek yoktur.(YukarÄ±daki arrow fonksiyon buna Ã¶rnektir.)
- Ancak parametrelerden sonra birden fazla kod bloÄŸu Ã§alÄ±ÅŸtÄ±rÄ±lacak ise sÃ¼slÃ¼ parantezlerin konulmasÄ± zorunludur ve geriye deÄŸer dÃ¶ndÃ¼rÃ¼lecek ise **_return_** bildiriminin yapÄ±lmasÄ± zorunludur. (AÅŸaÄŸÄ±daki arow fonksiyon buna Ã¶rnektir.)

```
// parantezler bize birden fazla statement yazmamÄ±zÄ± saÄŸlar.
let toplam = (a, b) => {
  let result = a + b;
  return result;
};
```

**Recursion**

- En basit tanÄ±m ÅŸekli ile bir fonksiyon kendisini tekrar Ã§aÄŸÄ±rÄ±yor ise buna recursion denir.

```
alert(pow(2, 3)); // 8
// recursion ile
function pow(x, n) {
  if (n == 1) {
    return x;
  } else {
    return x * pow(x, n - 1);
  }
}

alert(pow(2, 3)); // 8
```

YukarÄ±daki Ã¶rnekte n == 1 ise iÅŸlem yapmadan geriye 1 deÄŸerini dÃ¶ndÃ¼rerek fonksiyonun Ã§alÄ±ÅŸmasÄ± saÄŸlanÄ±r ancak n deÄŸeri 1 den farklÄ± ise **_pow_** n == 1 olana kadar Ã§aÄŸÄ±rÄ±lacak ve en sade haline gelene kadar dÃ¶necek ve sonunda sonucu bize dÃ¶ndÃ¼recektir.

```
const pow = (x, n) => n == 1 ? x : x * pow(x, n-1);
```

**Nested Functions**

- Nested functions (Ä°Ã§ iÃ§e fonksiyonlar) Javascriptte yaygÄ±nolarak kullanÄ±lan bir yapÄ±dÄ±r.
- Bir fonksiyon iÃ§erisinde baÅŸka bir foksiyon tanÄ±mladÄ±ÄŸÄ±mÄ±zda bu yapÄ±ya nedted funtions yapÄ±sÄ± denir.

**Fonksiyona Parametre (params) Atamak ve GeridÃ¶nÃ¼ÅŸ (return) Alma**

Temel kurallar aÅŸaÄŸÄ±daki gibidir.

- Bir fonksiyon bir veya daha fazla parametre alabilir veya hiÃ§ almaya dabilir.
- Bir fonksiyon geriye deÄŸer dÃ¶ndÃ¼rÃ¼yor olabilir (return) yada dÃ¶ndÃ¼rmÃ¼yor da olabilir.
- MÃ¼mkÃ¼n olduÄŸuÃ¶lÃ§Ã¼de fonksiyonun baÄŸÄ±mlÄ±lÄ±klarÄ±nÄ± azaltmak gerekir.

**_Anahtar Not:_**
Bir fonksiyon aÅŸaÄŸÄ±daki bigi kullanÄ±ldÄ±ÄŸÄ±nda ve parametreye deÄŸer atanmadÄ±ÄŸÄ±nda parametre kullanÄ±ldÄ±ÄŸÄ± noktada **_undefined_** olacak ve duruma gÃ¶re hata alÄ±nabilir.

```
const hello = (firstName) => console.log(`Merhaba ${firstName}`);

hello (); // Merhaba undefined
```

YukarÄ±daki hatalÄ± durumdan kurtulmak iÃ§in

- Kontrol saÄŸlanabilir

```
const hello = (firstName) => console.log(`Merhaba ${firstName ? firstName : ""}`);

hello (); // Merhaba
```

- Yada default parametre atanabilir.

```
const hello = (firstName = "") => console.log(`Merhaba ${firstName ? firstName : ""}`);

hello (); // Merhaba
```

Fonksiyon aÅŸaÄŸÄ±daki ÅŸekilde ise geriye deÄŸer dÃ¶ndÃ¼recektir.

```
// Geriye deÄŸer dÃ¶ndÃ¼recektir. tek kod satrÄ±rÄ± kullandÄ±ÄŸÄ±mÄ±z iÃ§in return yazmamÄ±za gerek yoktur.
const hello = (firstName = "") => `Merhaba ${firstName ? firstName : ""}`;

let user = hello ("Ziya");
console.log(user); // Merhaba Ziya
```

**Ã‡alÄ±ÅŸma SorularÄ±**
1- Biz dizi veya film listesini parametre olarak alan bir arrow fonksiyon yazalÄ±m. VerdiÄŸimiz parametreleri 1-den baÅŸlayarak alt alta yazdÄ±ran fonksiyonu yazalÄ±m.

```
const myFavoriteMovies = (movieList) => {
  movieList.forEach((movie, index) => {
    console.log(`${index + 1}: ${movie}`);
  });
};

myFavoriteMovies([
  "The Martian",
  "Passengers",
  "Fast&Furious Series",
  "Marvel Series",
  "Top Gun: Maverick",
]);
```

2- [1,2,3,4,5] aarayini alan bir arrow fonksiyon yazalÄ±m. Fonksiyon bu arrayi alsÄ±n ve sonuÃ§ta bize gene bir array dÃ¶nsÃ¼n. Geriye dÃ¶nen bu yeni array ilk aldÄ±ÄŸÄ± arraydeki tek sayilarÄ± 3, Ã§ift sayÄ±larÄ± ise 2 ile Ã§arpÄ±mÄ±ndan oluÅŸsun.

```
const newArray = (arr) =>
  arr.map((number) => (number % 2 == 0 ? number * 2 : number * 3));

let myArr = newArray([1, 2, 3, 4, 5]);
console.log(myArr);
```

**DOM Etkinlikleri ile Ã‡alÄ±ÅŸma**

```
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>DOM Eklentileri ile Ã§alÄ±ÅŸma</title>
  </head>
  <body>
    <h1 id="my-title">Frontend Kodluyoruz.</h1>
    <script src="./dom-eklentileri.js"></script>
  </body>
</html>
```

Javascript kullanarak baÅŸlÄ±ÄŸÄ±mÄ±za ulaÅŸarak Ã¼zerine tÄ±klandÄ±ÄŸÄ±nda rengini deÄŸiÅŸtirelim.

```
// BaÅŸlÄ±ÄŸÄ±mÄ±za ulaÅŸarak Ã¼zerine tÄ±klandÄ±ÄŸÄ±nda rengini deÄŸiÅŸtirelim.
const myTitle = document.querySelector("#my-title");

myTitle.addEventListener("click", clicked);

function clicked() {
  this.style.color == "red"
    ? (this.style.color = "blue")
    : (this.style.color = "red");
}
```

Ãœzerine tÄ±kladÄ±ÄŸÄ±mÄ±zda yazÄ±yÄ± deÄŸiÅŸtirelim.

```
const myTitle = document.querySelector("#my-title");

function clickON() {
  myTitle.innerHTML = "Ãœzerine tÄ±klayarak YazÄ±yÄ± DEÄÄ°ÅTÄ°RDÄ°K";
}

myTitle.addEventListener("click", clickON);
```

## 4.20- Local Storage

Web storage, web sayfalarÄ±nda yapÄ±lan deÄŸiÅŸikliklerin kaydÄ±nÄ±n tutulmasÄ± ÅŸeklinde tanÄ±mlanÄ±r. Web sayfalarÄ±nda yapÄ±lan deÄŸiÅŸikliklerin kaydÄ±nÄ± tutmak gerekebilir. Ã–rneÄŸin bir form doldurduÄŸumuzu dÃ¼ÅŸÃ¼nelim ve sayfadan Ã§Ä±kÄ±p yeniden girdiÄŸimizde formu sÄ±fÄ±rdan doldurmak sinir bozucu bir durum olarak karÅŸÄ±mÄ±za Ã§Ä±kar. BÃ¶yle durumlarda kayÄ±tlar cookie yani Ã§erezlerde tutulurdu. Ancak Ã§erezlerin 4kb ile sÄ±nÄ±rlÄ± olmasÄ± ve de Ã¼Ã§Ã¼ndÃ¼ ÅŸahÄ±slar tarafÄ±ndan kolayca eriÅŸilebilyor olmasÄ± local storage kavramÄ±nÄ±n yaygÄ±nlaÅŸmasÄ±nÄ± saÄŸlamÄ±ÅŸtÄ±r. HTML 5 ile birlikte web sayfasÄ±ndaki bu ve benzeri bilgiler local storage lerde saklanabiliyor duruma gelmiÅŸtir.

HTML 5 ile tarayÄ±cÄ±lar iki tane yerel kayÄ±t tÃ¼rÃ¼nÃ¼ desteklemektedir.

- localStorage
- sessionStorage

Bu iki kayÄ±t tÃ¼rÃ¼ arasÄ±ndaki temel fark local storage de kayÄ±tlar zaman aÅŸÄ±mÄ± olmaksÄ±zÄ±n tutulabiliyorken sessionStorage de ise oturum sonlanana kadar yada veri kaybolana kadar tutulmaktadÄ±r.

**Veri Ekle**

```
localStorage.setItem("key", "value");  // birinci parametre key yani anahtar ikinci ise value yani anahtara karÅŸÄ±lÄ±k gelen veri
```

**Veri Okuma**

```
localStorage.getItem("key");
```

**Veri Silme**

```
localStorage.removeItem("key");
	localStorage.clear();
```

[---> Ekteki Ã¶rneÄŸi inceleyeren kendiniz denemeler yapÄ±nÄ±z](./Javascript-Dersleri/localStorage/index.html)

**LocalStorage Ä°Ã§ine FarklÄ± TÃ¼rde Veriler Eklemek**
LocalStorage Ã¼zerinde farklÄ± tÃ¼rden verileri saklamak iÃ§in verileri _string_ tÃ¼rÃ¼ne dÃ¶nÃ¼ÅŸtÃ¼rmemiz gerekir.

- FarklÄ± tÃ¼rden verileri stringe Ã§evirerek localStorage de saklamak iÃ§in **_JSON.stringify()_** metodu kullanÄ±lÄ±r.
- FarklÄ± tÃ¼den verileri localStorage den Ã§ektiÄŸimizde ise **_JSON.parse()_** metodu ile Ã§evirmemiz gerekir. Aksi durumda object olarak gÃ¶rÃ¼necektir.

```
let user = {userName : "ziya", isActive : true};
localStorage.setItem("user", JSON.stringify(user));
```

**locakStorage den verileri Ã§ekme:**

```
let userInfo = JSON.parse(localStorage.getItem("user"));
```

**[---> localStorage UYGULAMA linkten inceleyiniz ](./Javascript-Dersleri/localStorage/uygulama/)**

## 4.21- Form ve Form Submit YÃ¶netimi

- Formlar iÃ§inde bulundurduklarÄ± form elementlerinin name'leri sayesinde deÄŸerlerini alÄ±p bu deÄŸerler ile iÅŸlem ypmammÄ±zÄ± saÄŸlayan yapÄ±lardÄ±r.
- Genelde backend e istek yapÄ±lacaÄŸÄ±nda kullanÄ±lÄ±rlar( Ã–rnek: verik gÃ¶nderme).
- En Ã¶nemli parametresi **_Metot_** parametresidir. **Metot**, **"get"** ve **"post"** olamk Ã¼zere iki farklÄ± deÄŸer alabilir.

```
<form action="siteadi" Metot="get|post">*form elementleri*</form> // form bu ÅŸekilde tanÄ±mlanmaktadÄ±r.
```

**GET Metotu**

- form verilerini URL Ã¼zerinden gÃ¶nderir.

```
<form Metot="GET"><input type="text" name="yas" placeholder="YaÅŸÄ±nÄ±zÄ± giriniz." /><button type="submit">GÃ¶nder</button>
</form>
```

**POST Metotu**

- Verileri arka planda gÃ¶nderir.
- Ã–nemli verilerin (username, password,user email gibi) gÃ¶nderilmesinde kullanÄ±cÄ±ya gÃ¶sterilmeden gÃ¶nderim saÄŸlanÄ±r.

```
<form Metot="POST"><input type="email" name="email" placeholder="Email adresinizi giriniz." /><button type="submit">GÃ¶nder</button>
</form>
```

**GiriÅŸ (Input) elementi/etiketi**

- Form oluÅŸturulduktn sonra iÃ§erisine deÄŸiÅŸik tiplerde (text,button,ÅŸifre v.b.) giriÅŸ elementleri eklenir.

En Ã§ok kullanÄ±lan giriÅŸ tiplerine biraz gÃ¶z atalÄ±m:

- `<input type="text">` Girilen veri text tipindedir. Yani diÄŸer bir deÄŸiÅŸle string veri tipinde gelen veridir. KullanÄ±cÄ± adÄ±, ad, soyad v.b.
- `<input type="password">` Åifre tipinde veri giriÅŸi iÃ§in tercih edilir.Textboxâ€™a girilen ifadeler **â€œ\*â€** ÅŸeklinde gizlenerek gÃ¶sterilir.
- `<input type="radio">` radio button tipinde , istenilen verieleri seÃ§mek iÃ§in geliÅŸtirilen bir inputtur.
- `<input type="button">` checkbox tipinde onay gerektiren durumlarda kullanÄ±lmasÄ± iÃ§in geliÅŸtirilmiÅŸ bir inputtur.
- `<input type="submit">` Klasik buton oluÅŸturur.VarsayÄ±lan olarak herhangi bir iÅŸlem yapmaz. JavaScript vb. programlama dilleri ile birlikte iÅŸlevsel hale gelir.
- `<input type="reset">` Form iÃ§erisinde elementlere girilen verileri gÃ¶ndermede kullanÄ±lÄ±r. Action ile aÃ§Ä±lacak yeni sayfa veya mevcut sayfanÄ±n kendisine get ve post Metotuna gÃ¶re deÄŸiÅŸik ÅŸekillerde veri gÃ¶nderme iÅŸlemini gerÃ§ekleÅŸtirir. methot="get" kullanÄ±lmÄ±ÅŸsa action durumunda gÃ¶re sayfanÄ±n adres Ã§ubuÄŸundaki urlâ€™in sonunda, methot="post" kullanÄ±lmÄ±ÅŸsa sayfanÄ±n arka planÄ±nda veriler saklanÄ±r.
- `<input type="color">` Button tipinde bir nesne oluÅŸturur. Form iÃ§erisinde yer alan elementlere veri girilmiÅŸ halde iken reset e basÄ±ldÄ±ÄŸÄ±nda elementler Ã¼zerinde gÃ¶rÃ¼nen bÃ¼tÃ¼n veriler silinir ve form default haline geri dÃ¶ner.
- `<input type="date">` Renk Ã§eÅŸitlerini tasarÄ±mcÄ±ya sunan ve seÃ§im yapmasÄ±nÄ± saÄŸlayan giriÅŸ veri tipidir.
- `<input type="email">` Sadece email bilgisi giriÅŸi iÃ§in tasarlanmÄ±ÅŸ bir inputtur. SayÄ± dÄ±ÅŸÄ±ndaki giriÅŸlerde, dÃ¼zgÃ¼n veri giriÅŸi yapÄ±lmasÄ± gerektiÄŸi yÃ¶nÃ¼nde uyarÄ± vermektedir. Safari dÄ±ÅŸÄ±ndaki tÃ¼m tarayÄ±cÄ±lar desteklemektedir.
- `<input type="number">` Sadece sayÄ± giriÅŸleriiÃ§in kullanÄ±lan bir inputtur. SayÄ± dÄ±ÅŸÄ±nda veri giriÅŸi yapÄ±ldÄ±ÄŸÄ±nda uyarÄ± verir.
- `<input type="range">` Bir aralÄ±k belirtmemiz gerektiÄŸinde, bu giriÅŸ tipini kullanmamÄ±z gerekmektedir. Dizi ÅŸeklinde veri gÃ¶sterimi yapar. min="baÅŸlangÄ±Ã§ deÄŸer" ve max="son deÄŸer" ile aralÄ±k belirlemesi yapÄ±lÄ±r. TÃ¼m tarayÄ±cÄ±lar tarafÄ±ndan desteklenmektedir.
- `<input type="search">` Arama yapmak iÃ§in eliÅŸtirilmiÅŸ bir inputtur. Aktif olan form iÃ§erisinde girilecek veri aranÄ±r. Sadece Google Chrome ve Safari tarafÄ±ndan desteklenmektedir.
- `<input type="time">` TarayÄ±cÄ±da saat gÃ¶sterimini saÄŸlayan tiptir. hh.mm varsayÄ±lan formatÄ±nda gÃ¶rÃ¼nÃ¼r. Element Ã¼zerinde saat belirlemesi yapÄ±lmasÄ± mÃ¼mkÃ¼ndÃ¼r. Ä°nternet Explorer ve Mozilla Firefox dÄ±ÅŸÄ±ndaki tarayÄ±cÄ±lar tarafÄ±ndan desteklenmektedir.

**onSubmit ve onChange Eventleri**

- **onSubmit** From submit olduÄŸu anda ne yapacaÄŸÄ±nÄ± sÃ¶yleyeceÄŸimiz eventtÄ±r.
- **onChange** Form'un iÃ§indeki form elementlerinin(input) value'su her deÄŸiÅŸtiÄŸinde bu deÄŸiÅŸen value'yu bizim her defasÄ±nda elde etmemize olanak saÄŸlayan eventtir.

**Ã–rnek**

```
<form Metot="GET">
  <input type="text" name="username" placeholder="KullanÄ±cÄ± adÄ±nÄ±zÄ± giriniz" />
  <input type="password" name="password" placeholder="Åifrenizi giriniz." />
  <button type="submit">GiriÅŸ</button>
</form>
```

YukarÄ±daki Ã¶rnek sonucunda submit ettiÄŸimizde **url** imizin deÄŸiÅŸtiÄŸini gÃ¶zlemleyebilirsiniz.

**Form Ã–zellikleri**
**- Action :** Form submit edildiÄŸinde nasÄ±l bir aksiyon alÄ±nacaÄŸÄ±nÄ± belirttiÄŸimiz koddur. Genellikle form submit iÅŸleminden sonra data server a gÃ¶nderilir.
**- Metot :** Form metodunun hangi metodla gÃ¶nderileceÄŸini belirtir. **"Get"** veya **"Post"** request olarak, bu Ã¶zellik belirtilmemiÅŸ ise default deÄŸer olarak **"Get"** mettodu forma aktarÄ±lÄ±r.
**- AUTOCOMPLETE** formu otomatik tamamlama Ã¶zelliÄŸinin aÃ§Ä±lÄ±p kapatÄ±ldÄ±ÄŸÄ± komut, bu Ã¶zellik aÃ§Ä±k olduÄŸunda daha Ã¶nceki entry lere gÃ¶re form otomatik olarak tamamlanacaktÄ±r.
**- NOVALIDATE** aktif olduÄŸu sÃ¼rece form datamÄ±zÄ±n otomatik olarak doÄŸrulanmamasÄ±nÄ± sÃ¶yler.

**ANAHTAR NOTLAR**
Formumuzun iÃ§erisinde olmazsa olmaz sayÄ±lan temel elementler inputlar ve botunlardÄ±r. Input elementlerinin baÅŸlÄ±ca Ã¶zellikleri ÅŸu ÅŸekildedir.
**- fname** GÃ¶rÃ¼necek olan yazÄ±yÄ± belirler. Bu yazÄ± adeta bit html etiketi gibi gÃ¶rÃ¼nÃ¼r.
**- type** formunuzun text/numerik bir form olacaÄŸÄ±na karar veririz.
**- name** Inputumuzun name Ã¶zelliÄŸi dir. Genelde isimler kÃ¼Ã§Ã¼k harf ile verilir.
**- value** Input iÃ§erisinde aktif olarak gÃ¶rÃ¼necek yazÄ± iÃ§in verilir.

**Input Ä°Ã§erisinden DeÄŸer Alma**

- Input oluÅŸturma

```
let myInput=document.createElement("input"); // input oluÅŸturuldu

/* Daha sonra inputumuza Ã¶zellikler aktaralÄ±m.*/

myInput.setAttribute("id", "myInput");
myInput.setAttribute("type","text");
myInput.setAttribute("value","Buraya YazÄ±n");
```

- oluÅŸturduÄŸumuz inputu html iÃ§erisine yerleÅŸtirelim.

```
let myDiv = document.createElement ("div"); // bir div oluÅŸturup onun iÃ§erisine yerleÅŸtirelim.

/*appendChild fonksiyonu ile input u div e ekleyelim.*/
myDiv.appendChild(myInput);
```

- Inputun DeÄŸerini alalÄ±m.

```
let inputDeger = document.getElementById("myInput").value;
console.log(inputDeger); // konsolda inputun deÄŸeri gÃ¶sterildi.
```

[---> Linkteki Ã¶rneÄŸi inceleyiniz...](./Javascript-Dersleri/form/Uygulama/)

## 4.22- Array (Dizi) OluÅŸturma ve Ä°Ã§erisindeki Elemanlara UlaÅŸma

- Array birden fazla deÄŸeri (value) iÃ§erisinde barÄ±ndÄ±ran yapÄ±dÄ±r.
- Array oluÅŸturmak iÃ§in kÃ¶ÅŸeli parantez kullanÄ±lÄ±r.

```
let numbers = [1,2,3,4,5,6]; // sayÄ±lardan oluÅŸan bir array tanÄ±mlandÄ±.

let arr = [1, 2, 3, true, "eleman", {name: "ziya", scrore : 99}]; // deÄŸiÅŸik tipte parametreli elemanlara sahip bir array tanÄ±mlandÄ±.
```

**- Array Ã§erisindeki elemana ulaÅŸmak iÃ§in:** array isminden sonra kÃ¶ÅŸeli parantezler iÃ§erisinde ulaÅŸmak istenilen elemanÄ±n index numarasÄ± belirtilir. Verilen index numarasÄ± dÄ±ÅŸÄ±nda bir index verilir ise geriye **undefined** dÃ¶ner.

**Type Of Array**

- Arraylerin tipi _object_'dir.

```
let numbers = [1,2,3,4,5,6];
console.log(typeOf numbers); // object
```

**Arraylerin Deklare Edilmesi (Let || const)**

- Arraylerin let ile tanÄ±mlanan bir array daha sonradan yeniden tanÄ±mlanabilir.

```
let gunler = ['pazartesi','sali','carsamba']
gunler = ['cuma','cumartesi','pazar']; // array yeniden tanÄ±mlanarak iÃ§erik deÄŸiÅŸtirilerek yeniden tanÄ±mlanmÄ±ÅŸtÄ±r.
```

- const ile deklare edilen bir array daha sonradan yeniden tanÄ±mlanamaz.

```
let gunler = ['pazartesi','sali','carsamba']
gunler = ['cuma','cumartesi','pazar']; // Error 'TypeError: Assignment to constant variable'
```

- Ancak const ile tanÄ±mlanmÄ±ÅŸ bir arrayÄ±n index ile ulaÅŸarak elemanÄ±na deÄŸiÅŸtirmek let ile aynÄ± yapÄ±labilir.

```
let gunler = ['pazartesi','sali','carsamba']
gunler[0] = 'Cuma';

```

## 4.23- Ã–nemli Array MetotlarÄ± (Diziye Yeni Eleman Eklemek, Ã‡Ä±kartmak ve GÃ¼ncellemek Diziye Yeni Eleman Eklemek)

**- Dizilere **_.push(), .unshift() ve .splice()_** metotlarÄ±yla yeni eleman ekleyebiliriz.**

```
const arr = [];

arr.push("zero");
arr.push("one");
arr.push("two");
arr.push("three");

console.log(arr); // [ 'zero', 'one', 'two', 'three' ]
```

- **_.unshift()_** Metotu dizinin baÅŸÄ±na eleman ekler.

```
const arr = [];

arr.unshift(3);
arr.unshift(2);
arr.unshift(1);
arr.unshift(0);

console.log(arr); // [ 0, 1, 2, 3, 'zero', 'one', 'two', 'three' ]
```

**Diziden Elemena Silmek**

- Dizilerden eleman silmek iÃ§in **_pop(), shift(), splice()_** metodlarÄ± kullanÄ±labilir.
  **_.pop() Metot_**

```
const arr = [ 0, 1, 2, 3, 'zero', 'one', 'two', 'three' ];

arr.pop();
arr.pop();
arr.pop();
arr.pop();

console.log(arr); // [ 0, 1, 2, 3 ]
```

**Anahtar NOT**

- pop() Metotu dizinin sonundan bir eleman siler. Her Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ±nda sondan bir eleman silinecektir.
- pop() Metotu Ã§alÄ±ÅŸtÄ±ÄŸÄ±nda dizinin sonundan bir eleman silinir. Metot Ã§Ä±ktÄ±sÄ± olarakda silinen eleman geriye dÃ¶ndÃ¼rÃ¼lÃ¼r. Yani istersek bir bu elemanÄ± yakalayabiliriz.
- pop() Metotu parantez iÃ§erisine parametre almaz.

```
const arr = [ 0, 1, 2, 3, 'zero', 'one', 'two', 'three' ];
let decNum = arr.pop();
console.log("Silinen Eleman :", decNum); // Silinen Eleman : three
```

**_.shift() Metot_**

```
const arr = [ 0, 1, 2, 3, 'zero', 'one', 'two', 'three' ];

arr.shift();
arr.shift();
arr.shift();
arr.shift();

console.log(arr); // [ 'zero', 'one', 'two', 'three' ]
```

**Anahtar NOT**

- shift() Metotu dizinin baÅŸÄ±ndan bir eleman siler. Her Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ±nda dizinin ilk elemanÄ± silinecektir.
- diziden silinen ilik eleman geriye dÃ¶necektir.

```
const arr = [ 0, 1, 2, 3, 'zero', 'one', 'two', 'three' ];
let decNum = arr.shift();
console.log("Silinen Eleman :", decNum); // Silinen Eleman : 0
```

**_.splice() Metot_**

- splice() Metotu ile bir diziden hem eleman silinebilir hem de eleman eklenebilir.
- diziye eleman ekleme:

```
let nums = [1, 4];
console.log(nums); // [ 1, 4 ]

nums.splice(1,0,2,3); // 1. elemandan itibaren baÅŸla ve 0 tane sil ve 2, 3 elemanlarÄ±nÄ± ekle
console.log(nums); // [ 1, 2, 3, 4 ]
```

**Dizide Eleman GÃ¼ncellemek**
Dizinin elemanlarÄ±na index numarasÄ±nÄ± kullanarak ulaÅŸabiliriz. Bu sayede istenilen elemanÄ± gÃ¼ncelleyebiliriz.

```
let myNums = [ 1, 2, 3, 4 ];
myNums[1] = "iki";
myNums[2] = "Ã¼Ã§";
console.log(myNums); // [ 1, 'iki', 'Ã¼Ã§', 4 ]
```

**_.includes() Metot_**

- Bu Metot dizi iÃ§erisinde bir elemanÄ±n bulunup bulunmadÄ±ÄŸÄ±nÄ± kontrol eder. Ve geriye Boolean (true/false) bir deÄŸer dÃ¶ner

```
const meyveler = ["elma", "armut", "kavun", "karpuz"];

const kavunvar = meyveler.includes("kavun");
console.log("Kavun var mÄ± : ", kavunvar); // Kavun var mÄ± :  true

```

**_.slice() Metot_**

- .slice() mthodu dizinin bil kÄ±smÄ±nÄ± dilimlememize olanak saÄŸlar. Ve geriye yeni bir dizi olarak dÃ¶ner.
- Parantez iÃ§erisine dilimlemek istediÄŸimiz aralÄ±ÄŸÄ±n baÅŸlangÄ±Ã§ ve bitiÅŸ ve bitiÅŸ indexlerini yazarÄ±z. Burada dikkat etmemiz gereken; bitiÅŸ index i almak istediÄŸimiz aralÄ±ÄŸa dahil deÄŸildir.
- Bu Metot dizimizin orjinal halini deÄŸiÅŸtirmemekte yeni oluÅŸan dizi ise farklÄ± bir deÄŸiÅŸkende tutulmalÄ±dÄ±r.

```
const someNumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];

const newArray = someNumbers.slice(2, 5);  // 2. indexten itibaren baÅŸla ve 5. elemana kadar al
console.log(".slice() ile oluÅŸan yeni Array :", newArray); // .slice() ile oluÅŸan yeni Array : [ 3, 4, 5 ]
console.log(someNumbers); // [1, 2, 3, 4, 5, 6, 7, 8, 9]
```

**_.join() Metot_**

- Bu Metot bir array iÃ§erisinde yer alan bÃ¼tÃ¼n elemanlarÄ± birleÅŸtirerek _string_ bir ifade olarak geri dÃ¶ndÃ¼rÃ¼r.
- Parantes iÃ§erisinde herhangi bir deÄŸer vermez isek default deÄŸer olarak araya virgÃ¼l koyarak string ifade oluÅŸturulur.
- Mevcut diziye dokunmaz geriye string bir deÄŸer dÃ¶ner.

```
// const str = someNumbers.join(); //1. satÄ±r
// const str = someNumbers.join("-"); //2. satÄ±r
const str = someNumbers.join(""); //3. satÄ±r
// console.log(str); // 1,2,3,4,5,6,7,8,9 // 1.satÄ±r sonucu
// console.log(str); // 1-2-3-4-5-6-7-8-9 // 2.satÄ±r sonucu
console.log(str); // 123456789 // 3.satÄ±r sonucu
console.log(someNumbers); // [1, 2, 3, 4, 5, 6, 7, 8, 9]

```

**_.concat() Metot_**

- Bu Metot ise iki diziyi birleÅŸtirmekiÃ§in kullanÄ±lÄ±r.
- Geriye oluÅŸan yeni diziyi dÃ¶ner.

```
const numbers = [1, 2, 3, 4, 5, 6];
const strNums = ["bir", "iki", "Ã¼Ã§", "dÃ¶rt", "beÅŸ"];

const newNumbers = numbers.concat(strNums);

console.log(newNumbers); // [1, 2, 3, 4, 5, 6, "bir", "iki", "Ã¼Ã§", "dÃ¶rt", "beÅŸ"]
```

**_.forEach() Metot_**

- Bu Metot parametre olarak iÃ§erisine bir fonksiyon alÄ±r ve bu ÅŸekilde diziyi manipÃ¼le edebiliriz.
- Bu Metot sonunda **geriye herhangi bir deÄŸer DÃ–NMEZ.**

```
gunler.forEach((gun) => {
  console.log("GÃ¼nler BÃ¼yÃ¼k Harfle :", gun.toUpperCase());
});
```

**_.map() Metot_**

-Map metodu da forEach gibi kendisine verilen fonksiyonu dizinin her elemanÄ± iÃ§in uygular fakat forEach'ten farklÄ± olarak sonucu yeni bir dizide tutar.

- Orijinal dizi olduÄŸu gibi kalÄ±r.

```
const gunler = [
  "pazar",
  "pazartesi",
  "salÄ±",
  "Ã§arÅŸamba",
  "perÅŸembe",
  "cuma",
  "cumartesi",
];

const newDays = gunler.map((gun) => gun.toUpperCase());
console.log(newDays);  // ['PAZAR', 'PAZARTESI', 'SALI', 'Ã‡ARÅAMBA', 'PERÅEMBE', 'CUMA', 'CUMARTESI']
```

**_.some() Metot_**

- Dizi iÃ§erisinde bir elemanÄ±n var olup olmadÄ±ÄŸÄ±nÄ± sorgulamak iÃ§in kullanÄ±lÄ±r.
- Bu Metot da parametre olarak bir fonksiyon alÄ±r
- Dizinin bÃ¼tÃ¼n elemanlarÄ± ile fonksiyon ektileÅŸime girer ve sonuÃ§ olarak geriye true/false dÃ¶ner
- ektileÅŸime giren deÄŸer dizi elemanlarÄ±ndan birinde bile true olsa geriye true dÃ¶ner.

```
const sayilar = [1, 2, 3, 4, 5, 6, 7, 8, 9];

const tekSayiVarmi = sayilar.some((sayi) => sayi % 2 !== 0);
console.log(tekSayiVarmi);  //true
```

YukarÄ±daki Ã¶rnek ile aÅŸaÄŸÄ±dakiÃ¶rneÄŸi karÅŸÄ±laÅŸtÄ±rÄ±nÄ±z.

```
const sayilar = [2, 4, 6, 8, 10];

const tekSayiVarmi = sayilar.some((sayi) => sayi % 2 !== 0);
console.log(tekSayiVarmi); //false
```

EÅŸleÅŸen tek bir deÄŸer bile olsa true dÃ¶ner

```
const sayilar = [2, 4, 6, 8, 9, 10];

const tekSayiVarmi = sayilar.some((sayi) => sayi % 2 !== 0);
console.log(tekSayiVarmi); //true
```

**_.every() Metot_**

- every metodu belirtilen bir koÅŸulun dizideki tÃ¼m elemanlara uyup uymadÄ±ÄŸÄ±nÄ± kontrol ederiz.
- some metodunda olduÄŸu gibi, Boolean yani true veya false olarak dÃ¶ner.
- Parametre olarak bir fonksiyon alÄ±r
- True dÃ¶nebilmesi iÃ§in dizideki tÃ¼m elemanlarÄ±n fonksiyondaki koÅŸula uymasÄ± gerekir.

```
const sayilar = [2, 4, 6, 8, 9, 10];

const result = sayilar.every((sayi) => sayi >= 2); // dizinin sayÄ±larÄ± 2 den bÃ¼yÃ¼k veya eÅŸit mi?
console.log(result); // true
```

```
const sayilar = [2, 4, 6, 8, 9, 10];

const result = sayilar.every((sayi) => sayi > 5); // dizinin sayÄ±larÄ± 5 den bÃ¼yÃ¼k mÃ¼?
console.log(result); // false
```

**_.filter() Metot_**

- filter metodu bir dizi iÃ§erisindeki belirli bir koÅŸulu saÄŸlayan elemanlar ile yeni bir dizi oluÅŸturmamÄ±za dolayÄ±sÄ±yla dizi elemanlarÄ±nÄ± filtrelememize yarÄ±yor.
- Geriye yeni bir dizi dÃ¶ner ve oluÅŸan bu diziyi yeni bir deÄŸiÅŸkende saklÄ±yoruz.
- Orjinal dizimiz Ã¼zerinde herhangi bir deÄŸiÅŸiklik yapmayacaktÄ±r.

```
const someNumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];

const tekSayilar = someNumbers.filter((sayi) => sayi % 2 !== 0);
console.log(tekSayilar); // [ 1, 3, 5, 7, 9 ]
```

**_.find() Metot_**

- Bu Metot belirtilen koÅŸula uyan elemanÄ± bulmamÄ±zÄ± saÄŸlar.
- DiÄŸer metodlarÄ±n aksine _find_ Metotu elemanÄ±n kendisini dÃ¶ner
- koÅŸulu saÄŸlayanbirden fazla eleman var ise bulduÄŸu ilk elemanÄ± dÃ¶ner.
- KoÅŸulu saÄŸlayan bir eleman bulamaz ise _undefined_ dÃ¶ner

```
const someNumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];

const sonuc = someNumbers.find((sayi) => sayi > 4);
console.log(sonuc);  // 5
```

**_.sort() Metot_**

- Bu Metot ile dizi iÃ§erisindeki elemanlarÄ± sÄ±ralama yapabiliriz.
- Orjinal dizi sÄ±ralanmÄ±ÅŸ olarak geri dÃ¶ner.
- EÄŸer parametre olarak bir fonksiyon verilmezse dizi elemanlarÄ± string'e Ã§evrilir ve UTF-16 deÄŸerlerine gÃ¶re sÄ±ralanÄ±r.
- Artan veya azalan olarak sÄ±ralamak iÃ§in (sayi1-sayi2)-> artan, (sayi2-sayi1)-> azalan ÅŸeklinde parametreler verilir. AÅŸaÄŸÄ±daki Ã¶rnekleri inceleyiniz.

```
const someNumbers = [1, 3, 2, 6, 4, 9, 5, 8, 7];
someNumbers.sort((a, b) => a - b);
console.log("Dizinin kÃ¼Ã§Ã¼kten bÃ¼yÃ¼ÄŸe sÄ±ralanmasÄ± : ", someNumbers); //Dizinin kÃ¼Ã§Ã¼kten bÃ¼yÃ¼ÄŸe sÄ±ralanmasÄ± : [1, 2, 3, 4, 5, 6, 7, 8, 9]

someNumbers.sort((a, b) => b - a);
console.log("Dizinin bÃ¼yÃ¼kten kÃ¼Ã§Ã¼ÄŸe sÄ±ralanmasÄ± : ", someNumbers); //Dizinin kÃ¼Ã§Ã¼kten bÃ¼yÃ¼ÄŸe sÄ±ralanmasÄ± : [1, 2, 3, 4, 5, 6, 7, 8, 9]
```

**_.reduce() Metot_**

- Bu metot dizimizi yalnÄ±zca bir deÄŸere indirger.
- Parantez iÃ§erisine parametre olarak bir fonksiyon ve accumulator'Ã¼n (toplayÄ±cÄ±nÄ±n) baÅŸlangÄ±Ã§ deÄŸeri girilir
- Bu metot orijinal diziyi deÄŸiÅŸtirmez
- Tam olarak ne yaptÄ±ÄŸÄ±nÄ± anlamak iÃ§in aÅŸaÄŸÄ±daki Ã¶rnekleri inceleyelim.

```
const sayilar = [10,20,30];

// Dizi iÃ§indeki sayÄ±larÄ± toplayarak indirgeyecek bir fonksiyon yazalÄ±m:
function indirgeyici (akumulator, sayi) {
    return akumulator + sayi;
}

// Bu fonksiyonu ve toplamaya 0'dan baÅŸlayacaÄŸÄ±mÄ±zÄ± belirten 0 sayÄ±sÄ±nÄ± metodumuza parametre olarak girelim ve sonucu bir deÄŸiÅŸkende tutalÄ±m:
const sonuc1 = sayilar.reduce(indirgeyici,0);

console.log(sonuc1);
//0 + 10 + 20 + 30 = 60 olacaÄŸÄ±ndan Ã§Ä±ktÄ± olarak 60 bekleriz.



// EÄŸer akÃ¼mÃ¼latorÃ¼mÃ¼zÃ¼ 0 yerine 5'den baÅŸlatsaydÄ±k Ã§Ä±kabilecek sonucu gÃ¶relim:

const sonuc2 = sayilar.reduce(indirgeyici, 5);

console.log(sonuc2);
// 5 + 10 + 20 + 30 = 65 olacaÄŸÄ±ndan Ã§Ä±ktÄ± olarak 65 bekleriz.
```

**Dizi Ä°Ã§erisinde Dizi TanÄ±mlama**

- Dizi iÃ§erisinde dizi bir eleman olarak bir dizi alabilir.

```
const ogrenciler = [
  ["ziya", "caylan"],
  ["ali", "veli"],
  ["hasan", "hÃ¼seyin"],
  ["salim", "malim"],
];
```

[-->Daha iyi kavrayabilmek iÃ§in linkteki Ã¶rnekleri inceleyiniz ve Ã¶rnekleri Ã§oÄŸaltÄ±nÄ±z.](./Javascript-Dersleri/Array/02-alistirmalar.js)

## 4.24- DÃ–NGÃœLER

**JavaScript for DÃ¶ngÃ¼sÃ¼ KullanÄ±mÄ±**
For dÃ¶ngÃ¼sÃ¼nde koÅŸul saÄŸlandÄ±ÄŸÄ± sÃ¼rece dÃ¶ngÃ¼ tekrarlanacak koÅŸul saÄŸlanmadÄ±ÄŸÄ± anda dÃ¶ngÃ¼den Ã§Ä±kÄ±lacaktÄ±r. Syntax aÅŸaÄŸÄ±daki gibidir.

```
for (BaÅŸlangÄ±Ã§AtamasÄ±; KoÅŸulÄ°fadesi; dÃ¶ngÃ¼SonundaÃ‡alÄ±ÅŸacakÄ°fade) {
  "KoÅŸul saÄŸlanÄ±yorsa(true) Ã§alÄ±ÅŸmasÄ±nÄ± istediÄŸim komutlar."
};
"KoÅŸul saÄŸlanmazsa(false) dÃ¶ngÃ¼den Ã§Ä±kÄ±lÄ±r."
```

**Ã–rnek :**

```
for(let i = 1; i < 5; i++) {
    console.log(i); // ekrana index deÄŸeri yazdÄ±rÄ±lÄ±yor
};
```

**Break ve Continue KullanÄ±mÄ±**

- Bazen dÃ¶ngÃ¼lerde istediÄŸimiz anda istediÄŸimiz bilgi saÄŸlanmÄ±ÅŸ ve artÄ±k dÃ¶ngÃ¼nÃ¼n dÃ¶nmesine ihtiyaÃ§ kalmamÄ±ÅŸ olabilir. BÃ¶yle bir durumda dÃ¶ngÃ¼nÃ¼n devam etmesine gerek yoktur. DÃ¶ngÃ¼den Ã§Ä±kmamÄ±z gerekir. Ä°ÅŸte bbÃ¶yle bir durumda _break_ ifadesi kullanÄ±lÄ±r.
- Break ifadesi bulunduÄŸu dÃ¶ngÃ¼den Ã§Ä±kÄ±lmasÄ±nÄ± saÄŸlar. Yani iÃ§ iÃ§e dÃ¶ngÃ¼ler var ise sadece bulunduÄŸu dÃ¶ngÃ¼den Ã§Ä±kacak ancak bir Ã¼stteki dÃ¶ngÃ¼ dÃ¶nmeye devam edecektir.
- KoÅŸul sonsuz sÃ¶ngÃ¼ olursa sozsuz dÃ¶nmeye devam edecektir. Bazen bÃ¶yle durumlar isteriz. BÃ¶yle durumlardan Ã§Ä±kmak iÃ§in ise dÃ¶ngÃ¼ iÃ§erisinde kontrol ifadeleri kullanÄ±rÄ±z.

```
const users = ["ziya", "ali", "veli", "hasan", "eda", "meda"];

for (let i = 0; i < users.length; ++i) {
  if (users[i] === "veli") {
    break;
  }
  //...
  console.log(users[i]); // ekranda "ziya" ve "ali" yazacak diÄŸerleri yazÄ±lmayacak.
}

```

- Continue ifadesinde ise dÃ¶ngÃ¼ dÃ¶nmeye devam eder ancak program continue ifadesine geldiÄŸinde dÃ¶ndÃ¼ o kÄ±sÄ±mda dÃ¶nmeyi bÄ±rakÄ±r yani gÃ¶ngÃ¼nÃ¼n geri kalan komutlarÄ±nÄ± uygulamayÄ± bÄ±rakÄ±r ve sanki o andaki dÃ¶ngÃ¼ tamamlanmÄ±ÅŸ gibi dÃ¶ngÃ¼nÃ¼n baÅŸÄ±na giderek kaldÄ±ÄŸÄ± yerden itibaren dÃ¶nmeye devam eder. AÅŸaÄŸÄ±daki Ã¶rneÄŸi incelediÄŸimizide daha iyi anlaÅŸÄ±lacaktÄ±r.

```
const users = ["ziya", "ali", "veli", "hasan", "eda", "meda"];

for (let i = 0; i < users.length; ++i) {
  if (users[i] === "veli") {
    continue;
  }
  //...
  console.log(users[i]); // ekranda "ziya", "ali", "hasan", "eda", "meda" yazacak "veli" ise yazÄ±lmayacaktÄ±r.
}

```

// sonsuz dÃ¶ngÃ¼ ve Ã§Ä±kÄ±lmasÄ± Ã¶rnek
let idx = 0;
for (;;) {
console.log(`idx = ${idx}`);
if (idx === 25) {
break;
}
++idx;
}

**JavaScript While DÃ¶ngÃ¼sÃ¼ KullanÄ±mÄ±**

- for dÃ¶ngÃ¼sÃ¼ benzeridir.
- koÅŸul saÄŸlandÄ±ÄŸÄ± sÃ¼rece dÃ¶nmeye devam edecektir.
- Syntax aÅŸaÄŸÄ±daki gibidir.

```
while(koÅŸul) {
  // YapÄ±lacak iÅŸlem/iÅŸlemler;
}
```

```
const users = ["ziya", "ali", "veli", "hasan", "eda", "meda"];

let i = 0;
while (users[i]) {
  console.log(users[i]);  // "ziya", "ali", "veli", "hasan", "eda", "meda"
  ++i;
}

```

```
// while sonsuz dÃ¶ngÃ¼ ve istenildiÄŸi zaman Ã§Ä±kÄ±lmasÄ± Ã¶nneÄŸi
let idx = 0;
while (true) {
  console.log(`idx = ${idx}`);
  if (idx === 25) {
    break;
  }
  ++idx;
}
```

**JavaScript forEach KullanÄ±mÄ±**

- forEach dÃ¶ngÃ¼yÃ¼ sÄ±rayla Ã§alÄ±ÅŸtÄ±rmamÄ±zÄ± saÄŸlayan bir array metodudur.
- forEach fonksiyonu item, index, array olmak Ã¼zere 3 parametre alabilir.
- geriye herhangi bir deÄŸer dÃ¶nmez.Bir arrayÄ±n herbir elemanÄ± iÃ§in bir fonksiyon Ã§alÄ±ÅŸtÄ±rÄ±r ve geriye herhangi bir deÄŸer dÃ¶nmeyecektir.

```
arr.forEach(function(value, index, array) {
  // index ve array kullanmak opsiyoneldir
}
```

```
// farklÄ± bir Ã¶rnek
const names = [
  "ziya",
  "ali",
  "veli",
  "hasan",
  "eda",
  "meda",
  "seda",
  "ecrin",
  "mecrin",
];

names.forEach((value, index, arr) => {
  console.log("value: ", value); // names lerin o andi deÄŸerini ekrana yazdÄ±rÄ±r
  console.log("value parametresinin aldÄ±ÄŸÄ± index :", index); // dÃ¶ndÃ¼ÄŸÃ¼ esnadaki index deÄŸeri yazdÄ±rÄ±lÄ±r.
  console.log("arr:", arr); // bÃ¼tÃ¼n arr her seferinde yazdÄ±rÄ±lÄ±r
});
```

```
// names leri bÃ¼yÃ¼k fark olarak ekrana yazdÄ±ralÄ±m.
names.forEach((name) => console.log(name.toUpperCase()));
console.log(names); // dikkat edilir ise orjinal arrayimizde bir deÄŸiÅŸiklik olmamÄ±ÅŸtÄ±r.

const myResult = names.forEach((name) => console.log(name.toLocaleLowerCase()));
console.log(myResult); // undefined geriye bir deÄŸer dÃ¶nmediÄŸi gÃ¶zlemlenmiÅŸtir.
```

**Filter ile Array Ä°Ã§erisinde Sadece Ä°stenilen Bilgilerin Yeni Listeye Eklenmesi**
**Filter Metotu**

- Bu array Metotu dizi elemanlarÄ±nÄ± dÃ¶ngÃ¼ye sokarak istediÄŸimiz koÅŸulu saÄŸlayan elemanlarÄ± alarak yeni bir array oluÅŸturmamÄ±zÄ± saÄŸlar.
- Bu array Metotu, bir fonksiyon alÄ±r ve sonunda yeriye yeni bir array dÃ¶ndÃ¼rÃ¼r. Mevcut array Ã¼zerinde herhangi bir deÄŸiÅŸiklik yapmaz.

```
const products = ["Mikrofon","Kablo","Telefon","Bilgisayar","Mouse","Klavye","Ekran"];

const newProducts = products.filter((product) => product.length > 5); // string uzunluÄŸu 5 ten bÃ¼yÃ¼k olanlarÄ± yeni dizi olarak dÃ¶ner
console.log(newProducts); // [ 'Mikrofon', 'Telefon', 'Bilgisayar', 'Klavye' ]
```

```
// AÅŸaÄŸÄ±daki users dizisindeki nesneler iÃ§erisinden isActive'i true olanlarÄ± almak istiyorum.
const users = [
  { fullName: "Mehmet Veli", isActive: false },
  { fullName: "Ali Duran", isActive: true },
  { fullName: "Ahmet YÄ±lmaz", isActive: true },
  { fullName: "OÄŸuz Åahin", isActive: false },
];

const isActiveUsers = users.filter((user) => user.isActive === true);
console.log(isActiveUsers); // [{ fullName: 'Ali Duran', isActive: true },  { fullName: 'Ahmet YÄ±lmaz', isActive: true }]
```

[---> Linkteki alÄ±ÅŸtÄ±rma sorularÄ±nÄ± inceleyiniz.](./Javascript-Dersleri/D%C3%B6ng%C3%BCler/04-filter.js)

**Map ile Array Ä°Ã§erisideki YapÄ±nÄ±n DeÄŸiÅŸtirilerek Yeni Liste OluÅŸturulmasÄ±**

- .map() bir array Metotudur.
- Bu Metot mevcut arrayÄ±n Ã¼zerinde deÄŸiÅŸiklikler yaparak yeni bir array olarak geriye dÃ¶ner.

```
const names = [
  "ziya",
  "ali",
  "veli",
  "hasan",
  "eda",
  "meda",
  "seda",
  "ecrin",
  "mecrin",
];

const newNames = names.map((oneName) => oneName.toUpperCase());

console.log(names);    // ['ziya','ali','veli','hasan','eda','meda', 'seda','ecrin','mecrin']
console.log(newNames); //['ZIYA','ALI','VELI','HASAN','EDA','MEDA','SEDA','ECRIN','MECRIN']
```

```
const names = [
  "ziya",
  "ali",
  "veli",
  "hasan",
  "eda",
  "meda",
  "seda",
  "ecrin",
  "mecrin",
];


const USER_OBJ = names.map((user) => ({
  userName: `${user}`,
  shortName: `${user[0].toUpperCase()}`,
  newName: `${user[0].toUpperCase()}${user.slice(1).toLocaleLowerCase()}`,
}));
console.log(USER_OBJ);
```

YukarÄ±daki Ã¶rneÄŸin sonucunda konsolda gÃ¶rÃ¼ntÃ¼leneek yeni obje aÅŸaÄŸÄ±daki gibidir.

```
// yukarÄ±daki Ã¶rneÄŸin konsol Ã§Ä±ktÄ±sÄ±
[
  { userName: 'ziya', shortName: 'Z', newName: 'Ziya' },
  { userName: 'ali', shortName: 'A', newName: 'Ali' },
  { userName: 'veli', shortName: 'V', newName: 'Veli' },
  { userName: 'hasan', shortName: 'H', newName: 'Hasan' },
  { userName: 'eda', shortName: 'E', newName: 'Eda' },
  { userName: 'meda', shortName: 'M', newName: 'Meda' },
  { userName: 'seda', shortName: 'S', newName: 'Seda' },
  { userName: 'ecrin', shortName: 'E', newName: 'Ecrin' },
  { userName: 'mecrin', shortName: 'M', newName: 'Mecrin' }
]
```

```
// Ã–rnek 2: MaaÅŸ zam hesaplama; Ä°ÅŸÃ§ilerin aldÄ±klarÄ± maaÅŸlara ait bir dizi olsun. MaaÅŸÄ± 3000 TL'nin Ã¼zerinde olanlarÄ±nkine %15, altÄ±nda olanlarÄ±nkine de %25 zam yapan bir array map oluÅŸturalÄ±m.

const maaslar = [1100, 13000, 2500, 4500, 1500, 25000, 2000];

const newSalary = maaslar.map((salary) =>
  salary > 3000 ? Math.round(salary * 1.15) : Math.round(salary * 1.25)
);

console.log(`eski maaÅŸlar: ${maaslar}`); // eski maaÅŸlar: 1100,13000,2500,4500,1500,25000,2000
console.log(`ZamlÄ± maaÅŸlar: ${newSalary}`);  // ZamlÄ± maaÅŸlar: 1375,14950,3125,5175,1875,28750,2500
```

## 4.25- Object (Nesne) Nedir? NasÄ±l OluÅŸturulur?

Object yani objeler javascript te Ã§ok Ã¶nemli bir yere sahiptir. NasÄ±l Ã§alÄ±ÅŸtÄ±klarÄ±nÄ± anlamak bir frontend developer iÃ§in hayati Ã¶neme sahiptir. Bu nedenle Ã§ok iyi anlamamÄ±z gerekir.
**_TanÄ±mÄ± :_** Obje iÃ§erisinde birden fazla deÄŸeri depolayan yapÄ±lardÄ±r. _Property_ olarak bilinen bu deÄŸerler _primitive(String, number, boolean v.b.)_ veya baÅŸka objeler olabilir ve her bir deÄŸer string veya sembol ile isimlendirilebilir.

```
const cars = {
  model: "auris",
  brand: "toyota",
  release_year: 1998,
  users: { user1: "ziya", user2: "eda" },
};

```

**Obje OluÅŸturma**

- Obje 3 ÅŸekilde oluÅŸturulabilir.
- _new_ keyword'Ã¼ iel oluÅŸturulabilir.
- SÃ¼slÃ¼ parantezler ( { } ) kullanÄ±larak oluÅŸturulabilir.
- Son yÃ¶ntem ise _Object.create()_ yÃ¶ntemidir. Åimdi bu yÃ¶ntemleri Ã¶rnekler ile inceleyelim.

```
// new keyword'Ã¼ ile oluÅŸturma
let student = new Object();
student.name = "ziya";
student.lastname = "Ã§aylan";
student.age = 39;

console.log(student); // { name: 'ziya', lastname: 'Ã§aylan', age: 39 }
```

```
// SÃ¼slÃ¼ parantezler kullanÄ±larak oluÅŸturma
let phone = {
  brand: "samsung",
  model: "S7-edge",
  capacity: "32GB",
  ram: "4GB",
};

console.log(phone);  // { brand: 'samsung', model: 'S7-edge', capacity: '32GB', ram: '4GB' }
```

```
// Object.create yÃ¶ntemi
/*Herhanbi bir yerden kalÄ±tÄ±m almayacaksa _null_ parametresi atamamÄ±z gerekecektir.  */
let noInheritence = Object.create(null); //herhangi bir kalÄ±tÄ±m(inheritence) almaz

/*standartObject isimli obje Ã¶rneÄŸi, object literal ve new object keyword ile oluÅŸturulan objelerin prototiplerini parametre olarak aldÄ±ÄŸÄ± iÃ§in, onlar gibi Ã§alÄ±ÅŸÄ±r.*/
let standartObject = Object.create(Object.prototype); //standart obje kalÄ±tÄ±mÄ± alÄ±r.

let myPhone = Object.create(phone);
myPhone.brand = "Samsung";
myPhone.model = "S7";
myPhone.capacity = "96GB";
myPhone.ram = "4GB";

console.log(myPhone); // { brand: 'Samsung', model: 'S7', capacity: '96GB', ram: '4GB' }
```

**Object Anahtar(Key) ve DeÄŸer(Value) YapÄ±sÄ±nÄ±n KullanÄ±mÄ± ve MetodlarÄ±**
Bir objenin Syntax' Ä± aÅŸaÄŸÄ±daki gibidir.

_let-const object_name = { key : value }_

```
let car = {
 brand: "BMW", 	// key(anahtar) "brand" "BMW" value(deÄŸerini) tutar
 year: 2020,  		// key(anahtar) "year" 2020 value(deÄŸerini) tutar
};
```

- Property deÄŸerlerine noktalÄ± yazÄ±m(dot notation) kullanarak eriÅŸilebilir

```
console.log(car.brand); // "BMW"
```

- Birden fazla kelime iÃ§eren property name kullanabiliriz, ancak bunlar tÄ±rnak (" ") iÃ§inde kullanÄ±lmalÄ±dÄ±r:

```
let car = {
  brand: "BMW",
  year: 2020,
 "is manual" : true,
};
```

**- KÃ¶ÅŸeli Parantez (Square brackets ) KullanÄ±mÄ±**

- Birden fazla kelime iÃ§eren property'ler iÃ§in dot notation kullanamayÄ±z. Bunun yerine â€œsquare bracket notationâ€ yani kÃ¶ÅŸeli parantezli yazÄ±m kullanÄ±lÄ±r:

```
let person= {};                     // set (oluÅŸtur)
person["likes sea"] = true;         // get (getir)
console.log(person["likes sea"]);   // true (doÄŸru)
delete person["likes sea"];         // delete (sil)
```

- KÃ¶ÅŸeli parantezli yazÄ±m aynÄ± zamanda property name getirmede kullanÄ±labilir:

```
let animal= {};           // set
let key = "flies";        // key atama
animal[key] = true;       // value atama
```

**Computed property kullanÄ±mÄ±**

- Bir obje oluÅŸtururken key'ler iÃ§in kÃ¶ÅŸeli parantezler yardÄ±mÄ± ile dinamik deÄŸerler (variable) kullanabiliriz. Buna hesaplanmÄ±ÅŸ Ã¶aellikler (Computed property) denir.
- Computed properties, objedeki hangi property'nin gÃ¼ncelleneceÄŸini dinamik olarak seÃ§memize olanak tanÄ±r.

```
// Computed property

let updateObj = (key_1, value_1, key_2, value_2, key_3, value_3) => {
  return { [key_1]: value_1, [key_2]: value_2, [key_3]: value_3 };
};

let myCar = updateObj(
  "brand",
  "qashqai",
  "model",
  "qashqai",
  "release year",
  2016
);

console.log(myCar); //{ brand: 'qashqai', model: 'qashqai', 'release year': 2016 }
```

**Kompleks Objeler KullanÄ±mÄ±**
Objelerin asÄ±l amaÃ§larÄ±ndan biride yazÄ±lan uygulamalarÄ±n state'lerini yÃ¶netmektir. Bu nedenle kompleks uygulamalarda da kompleks objeler kullanÄ±lmaktadÄ±r. AÅŸaÄŸÄ±daki Ã¶rneÄŸi inceleyiniz:

```
let state = {
	users:[
		{name: "Brock", age: 25, favoriteColor: "red"},
		{name: "Jessie", age: 17, favoriteColor: "yellow"},
		{name: "James", age: 41, favoriteColor: "blue"},
		{name: "Winnie", age: 18, favoriteColor: "purple"}
	],
	settings:{
		version: "1.0.5",
        DNS: "105.xx.xx.xx",
        website: "https://www.example.com/"
	},
	banList: ["Ash", "Angelica", "Tom", "Jerry"]
}
```

YukarÄ±daki Ã¶rnekte propertilere ulaÅŸmayÄ± deneyelim.

```
console.log(state);

console.log(state.users[1].name); // state objesinin users property'sinin (ki bu property bir dizidir) 1. index'teki elemanÄ±nÄ±n ( buda bir objedir.) name property'si

console.log(state.settings.website); // https://www.example.com/
```

**JSON Veri Tipini Obje Olarak Kullanmak**
Projenizde JSON dosyalarÄ±yla Ã§alÄ±ÅŸabilmeniz iÃ§in Ã¶nce onu dosyada import etmeniz ve obje ÅŸekline Ã§evirmeniz gerekmektedir. Bu iÅŸlem Ã§ok basit bir ÅŸekilde yapÄ±labilir.

```
const veri = require("./dosyanizin/dizini/veri.json") // Bu iÅŸlemde require fonksiyonu ile dosyanÄ±zÄ± import etmektesiniz

// Bu iÅŸlemden sonra veri bileÅŸenini obje ÅŸeklinde kullanabilirsiniz.
```

**_Anahtar NOTLAR :_** **Ã–ZET**

- Objeler, birkaÃ§ Ã¶zel niteliÄŸe sahip iliÅŸkilendirilebilir array(dizi)'lerdir.
- Key / value ÅŸeklinde property'leri saklar.
- Key ifadesi string veya sembol olmalÄ±dÄ±r.
- Value ifadesi herhangi bir deÄŸer alabilir.
- Belli bir property'e eriÅŸmek iÃ§in kullanabileceklerimiz:
  - Dot notation: obj.property
  - Square brackets notation obj[â€œpropertyâ€]. Bu Ã¶zellik key'in obj[varWithKey] gibi bir deÄŸiÅŸkenden alÄ±nmasÄ±na izin verir.

Bu zamana kadar bahsettiÄŸimiz objeler â€œplain objectâ€ olarak isimlendirilir.

**Obje MetotlarÄ±**

- Object.keys(obj) â€“ Keyâ€™lerden oluÅŸan bir array dÃ¶ner(return).
- Object.values(obj) â€“ Valueâ€™lardan oluÅŸan bir array dÃ¶ner.
- Object.entries(obj) â€“ [key, value] Ã§iftlerinden oluÅŸan bir array dÃ¶ner.

TÃ¼m bu Object.\* metotlarÄ± array veri tipinde deÄŸer dÃ¶ner.

```
let person = {
  name: â€œJackâ€,
  age: 20
};

console.log(Object.keys(person)); //["name", "age"]
console.log(Object.values(person)); //["Jack", 20]
console.log(Object.entries(person)); //[ ["name","Jack"], ["age",20] ]
```

**JSON MetotlarÄ±**

- Objenizi String veri tÃ¼rÃ¼ne Ã§evirip, projenizde objelerinizi direk sayfaya basmak isterseniz, onun iÃ§inde bir metot bulunmakta.

```
//JSON MetotlarÄ±

let human = {
  name: "ziya",
  lastName: "Ã§aylan",
  age: 39,
};
let stringObject = JSON.stringify(human); // JSON tipine dÃ¶nÃ¼ÅŸtÃ¼rÃ¼ldÃ¼
console.log(stringObject);  // {"name":"ziya","lastName":"Ã§aylan","age":39}

let newHuman = JSON.parse(stringObject); // JSON tipinden obje tipine dÃ¶nÃ¼ÅŸtÃ¼rÃ¼ldÃ¼.

console.log(newHuman);  // { name: 'ziya', lastName: 'Ã§aylan', age: 39 }
```

**Nesnelere NasÄ±l Metot Ekleriz?**

- Nesnenin bir Ã¶zelliÄŸi bir fonksiyonu iÅŸaret ediyor ise buna metot denir.
- Metod nesneye iki ÅŸekilde eklenebilir.
  Birincisi : Nesneye property olarak elkeme
  Ä°kincisi : Nesneye prototype (prototip) fonksiyonu Ã¼zerinden eklemek.

```
/*Nesneye fonksiyon ekleme */
let developer = {
  name: "Ziya",
  surname: "Ã‡AYLAN",
  age: 39,
  city: "Ä°stanbul",
  introduce: function () {
    console.log(
      `My name is ${this.name} ${this.surname}, I'm ${this.age} years old.`
    );
  },
};

console.log(developer);
console.log(developer.introduce());
```

**AÅŸaÄŸÄ±daki Ã¶rnekte _constructor_ kullanarak da bir nesne tanÄ±mlama yapÄ±lmÄ±ÅŸtÄ±r.**

```
// Constructor
function ogrenci(isim, yas) {
  this.isim = isim;
  this.yas = yas;
}

const ali = new ogrenci("ali", 21);
console.log(ali.yas); // 21
console.log(ali);  // ogrenci { isim: 'ali', yas: 21 }

ali.yeniOzellik = "Sonradan eklenmiÅŸ bir Ã¶zellik";
console.log(ali.yeniOzellik); // "Sonradan eklenmiÅŸ bir Ã¶zellik"

console.log(ali.yas); // 21
console.log(ali); // ogrenci { isim: 'ali', yas: 21 }
```

**Objeye prototype yardÄ±mÄ±yla fonksiyon eklemek :**

```
//SÄ±nÄ±fa Prototype yardÄ±mÄ±yla fonksiyon eklemek :
ogrenci.prototype.yeniFonksiyon = () => {
  console.log("Merhaba Kodluyoruz");
};
const ayse = new ogrenci("ayÅŸe", 22);
ayse.yeniFonksiyon(); // "Merhaba Kodluyoruz"

ayse.__proto__.enYeniFonksiyon = () => {
  console.log("Tekrar Merhaba Kodluyoruz!");
};

ayse.enYeniFonksiyon();
// Output : "Tekrar Merhaba Kodluyoruz!"
```

**Object ve Array Destructuring KullanÄ±mÄ±**
**Destructuring Nedir?**
Destructuring bir obje veya bir arrayÄ±n iÃ§indeki her bir elemanÄ±nÄ±n alÄ±nÄ±p bir deÄŸiÅŸken iÃ§erisine kaydedilmesine denilmektedir.

```
const foo = {name: "ali", age:"25"}
```

```
// Object Destructuring
let settings = {
  userName: "ziya",
  password: "123456a",
  isActive: true,
  ip: "127.0.0.1",
  serverName: "kodluyoru.org",
};

const userName = settings.serverName;
console.log(userName);

let { userName: user, password: sifre, ...otherSettings } = settings;

console.log(user, sifre, otherSettings);
console.log(user);
console.log(sifre);
console.log(otherSettings);
```

**Rest Operator**
AÅŸaÄŸÄ±daki Ã¶rnekte tanÄ±mlamadÄ±ÄŸÄ±mÄ±z parametreleri kullanÄ±rsak, yani fazladan deÄŸer atamasÄ± yaparsak hata alÄ±rÄ±z.

```
const toplama = ({ sayi1, sayi2 }) => {
  // dikkat sadece 2 sayi
  return sayi1 + sayi2 + sayi3 + sayi4 + sayi5;
};
const numaralar = {
  sayi1: 8,
  sayi2: 4,
  sayi3: 7,
  sayi4: 9,
  sayi5: 11,
};
toplama(numaralar); //ReferenceError: sayi3 is not defined
```

Bu hatayÄ± dÃ¼zeltmek iÃ§in aÅŸaÄŸÄ±daki gibi _rest_ operatÃ¶rÃ¼ kullanarak sorunu Ã§Ã¶zÃ¼mleyebiliriz.

```
const toplama = ({ sayi1, sayi2, ...args }) => {
  let sonuc = sayi1 + sayi2;
  for (let sayi in args) {
    sonuc += args[sayi];
  }
  return sonuc;
};
const someNumbers = {
  sayi1: 8,
  sayi2: 4,
  sayi3: 7,
  sayi4: 9,
  sayi5: 11,
};
console.log("SayÄ±larÄ±n ToplamÄ± :", toplama(someNumbers)); // 39 doner
```

```
// Array Destructuring

const someStudents = ["ali", "veli", "hasan", "hÃ¼seyin", "mehmet", "ahmet"];

const [ali, veli, hasan, ...otherStudents] = someStudents;

console.log(ali);
console.log(otherStudents);
```

## 4.26- Hata Yakalama (Try Ve Catch KullanÄ±mÄ±)

_try...catch_ kÄ±saca bir iÅŸ yaparken herhangi bir hata ile karÅŸÄ±laÅŸma durumunun ele alÄ±nmasÄ± anlamÄ±nÄ± ifade etmektedir.
**try** kelimesi kodlarÄ± Ã§alÄ±ÅŸma zamanÄ±nda test etmek iÃ§in kullanÄ±lÄ±rken **catch** anahtar kelimesi ise hata ile karÅŸÄ±laÅŸÄ±lmasÄ± durumunda bu hatayÄ± yakalamak iÃ§in kullanÄ±lÄ±r.

Syntax aÅŸaÄŸÄ±daki gibidir.

```
try {
  //Ã‡alÄ±ÅŸtÄ±rÄ±lacak kodlar
}catch(hata) {
  //Hata yakalandÄ±ÄŸÄ±nda Ã§alÄ±ÅŸacak kodlar
}finally {
  //try tamamlandÄ±ktan sonra hata olsada olmasada Ã§alÄ±ÅŸacak olan kodlar.
}
```

**Throw Ä°le Ä°stisnalar OluÅŸturma**
Normalde kod Ã§alÄ±ÅŸÄ±rken herhangi bir hata ile karÅŸÄ±laÅŸÄ±lÄ±rsa Javascript durur ve bir hata mesajÄ± oluÅŸturur.

- JavaScript aslÄ±nda iki Ã¶zelliÄŸe sahip bir Error nesnesi oluÅŸturacaktÄ±r: isim ve mesaj.
- **throw** ifadesi bize Ã¶zel hatalar oluÅŸturmamÄ±za olanak tanÄ±r. Teknik olarak _throw_ ile bir istisna _(hata)_ atÄ±labilir.

## 4.27- Fetch API ile Ã‡alÄ±ÅŸmak

Fetch APÄ° kaynaklarÄ±n getirilmesine yÃ¶nelik basit bir arayÃ¼zdÃ¼r. Asenkron olarak veri alÄ±p gÃ¶ndermemize olanak saÄŸlamaktadÄ±r. Yani _Promise_ tabanlÄ± olduÄŸundan _async_ yapÄ±dadÄ±r. _Promise_ Ã¶zelliÄŸi _ES6_ ile birlikte gelen bir Ã¶zelliktir. Callback fonksiyonu yerine yazabiliriz.  
Bunu bir Ã¶rnekle aÃ§Ä±klamak gerekir ise; diyelimki biz bir kasadan sipariÅŸ verdik ve sipariÅŸi kasada bekliyoruz. Åayet sipariÅŸ gelene kadar kasada beklersek bir sonraki kiÅŸinin sipariÅŸ vermesini engellemiÅŸ oluruz. Ä°ÅŸte bu noktada sipariÅŸi verip kenarda beklerken kasa, "tamam ben senin sipariÅŸini aldÄ±m sana sÃ¶z veriyorum _(Promise)_ sipariÅŸini teslim edicem" deyip sÄ±radakinin de sipariÅŸini almasÄ± durumu bize uyugn bir Ã¶rnek olacaktÄ±r.

**- fetch()**, bu yÃ¶ntem bir kaynak almak iÃ§in kullanÄ±lÄ±r.

**- Headers**, response/request baÅŸlÄ±klarÄ±nÄ± temsil ederek bunlarÄ± sorgulamanÄ±za ve sonuÃ§lara baÄŸlÄ± olarak farklÄ± eylemler gerÃ§ekleÅŸtirmenize olanak tanÄ±r.

**- Request** , bir kaynak talebini temsil eder.

**- Response**, bir isteÄŸe verilen yanÄ±tÄ± temsil eder.

**Temel Fetch KullanÄ±mÄ±**
_fetch(url)_ Fetch api'yi kullanmak iÃ§in bu metoda istek yapacaÄŸÄ±mÄ±z url'i parametre olarak veriyoruz.

```
const url = "istek yapÄ±acak adres";

fetch(url);
```

- fetch() metodunun sonuna _then()_ promise metodunu ekleyebiliriz.

```
.then(function() {
})
```

AÅŸaÄŸÄ±daki Ã¶rneÄŸi inceleyelim:

```
const url = "https://jsonplaceholder.typicode.com/todos";

fetch(url).then((response) => response.json()) //parse json data
          .then(function (todos) {
                  todos.forEach((todo) => {
                    console.log(todo.title); // baÅŸlÄ±klarkonsola yazdÄ±rÄ±lÄ±yor.
                  });
          });
```

```
ğŸ’­ POST isteÄŸi ile verimizi servera gÃ¶nderelim
let payload = {
    title: "Blog Title",
    body: "lorem ipsum",
    userId:1
  }
  fetch('https://jsonplaceholder.typicode.com/posts', {
    method: "POST",
    body: JSON.stringify(payload),
    headers: {"Content-type": "application/json; charset=UTF-8"}
  })
  .then(response => response.json())
  .then(json => console.log(json))
  .catch(err => console.log(err));
```

**AÅŸama aÅŸama fetch().then().then().catch() yapÄ±sÄ±:**  
Åayet bir noktadahata ile karÅŸÄ±laÅŸÄ±rsan catch ile hatayÄ± yakalarÄ±z.  
![fetch-api yapÄ±sÄ±](./Javascript-Dersleri/assets/fetch-api.jpg)

Fetch-Api iÃ§in verimli bir Ã¶rnek;

```
let isError = false;
function getCategory() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (!isError) {
        resolve("phone");
      } else {
        reject("error");
      }
    }, 1500);
  });
}

function getProducts(category) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(`5 products in ${category}`);
    }, 1500);
  });
}

getCategory()
  .then(getProducts)
  .then((res) => console.log(res));

async function getProduct() {
  try {
    let category = await getCategory();
    let result = await getProducts(category);

    console.log(result);
  } catch (err) {
    console.log(err);
  }
}

```

**KAYNAKLAR**  
_- patika.dev_  
_- developer.mozilla.org_  
_- w3schools.com_  
_- medium.com_  
_- ethemkeskin.com_  
_- Json Placeholder API_  
_- Udemy_
