# <img src="https://img.shields.io/badge/HTML5-E34F26?style=for-the-badge&logo=html5&logoColor=white"/> <img src="https://img.shields.io/badge/CSS3-1572B6?style=for-the-badge&logo=css3&logoColor=white"/> <img src="https://img.shields.io/badge/JavaScript-323330?style=for-the-badge&logo=javascript&logoColor=F7DF1E"/> <img src="https://img.shields.io/badge/Bootstrap-563D7C?style=for-the-badge&logo=bootstrap&logoColor=white" /> <img src="https://img.shields.io/badge/Font_Awesome-339AF0?style=for-the-badge&logo=fontawesome&logoColor=white" />

# Ä°Ã‡Ä°NDEKÄ°LER

---

## 4. Javascript Dersleri

## 4.1-Javascript Nedir?

Javascript web programlama alanÄ±nda yaygÄ±n olarak kullanÄ±lan dinamik bir programlama dilidir. EtkileÅŸimli ve dinamik web sayfalarÄ± geliÅŸtirmeye yardÄ±mcÄ± olur. Ä°sminden dolayÄ± Java programala dili ile karÄ±ÅŸtÄ±rÄ±lÄ±r ancak her iki dilde birbirinden Ã§ok farklÄ± birer dildir. AralarÄ±ndaki benzerlik; yazÄ±m ÅŸekli ve standart kÃ¼tÃ¼phanelerÄ± dÄ±ÅŸÄ±nda bir baÄŸlantÄ± yoktur.

C programlama dilinden tÃ¼retilmiÅŸ, semantiÄŸi ve tasarÄ±mÄ± ise Self ve Sheme programlama dillerinden esinlenmiÅŸtir.

Javascript dili 1997 yÄ±lÄ±nda Netscape ÅŸirketinde Ã§alÄ±ÅŸan Brendan Eich tarafÄ±ndan gliÅŸtirilmiÅŸtir. Ä°lk Ã§Ä±ktÄ±ÄŸÄ± yÄ±llarda o deneme iat web tarayÄ±cÄ±larÄ±n bÃ¼yÃ¼k Ã§oÄŸunluÄŸu tarafÄ±ndan yorumlanamÄ±yordu ancak Brendan Eich bu dili geliÅŸtirmeye devam etti.Brendan Eich o dÃ¶nemlerde Mozilla VakfÄ±â€™nÄ± kurdu. Bu vakÄ±f gÃ¼nÃ¼mÃ¼zde hÃ¢lÃ¢ Javascript dilini geliÅŸtirmeye devam etmektedir.

### 4.2-ECMAScript'in Ortaya Ã‡Ä±kÄ±ÅŸÄ±

1996 yÄ±lÄ±nÄ±n kasÄ±m ayÄ±nda Netscape firmasÄ± Javascript'in endÃ¼stri standardÄ± olarak belirlenmesi amacÄ±yla ECMA International'a (Avrupa Bilgisayar Ãœreticileri BirliÄŸi) baÅŸvuruda bulunduÄŸunu ilan etti. Bunun sonucunda standardize edilen sÃ¼rÃ¼m ECMAJcript olarak isimlendirildi ve 1997 yÄ±lÄ±nÄ±n haziran ayÄ±nda ECMA International, ECMA-262 standartlarÄ± Ã§erÃ§evesinde ilk sÃ¼rÃ¼m ECMAScript (kÄ±saca ES) yanÄ±mlandÄ±.Haziran 1998'de ISO/IEC-16262 standardÄ±na uyumlu hale getirilecek deÄŸiÅŸiklikler yapÄ±larak ECMAScript 2, AralÄ±k 1999'da ise ECMAScript 3 yayÄ±nlandÄ±.

ECMAScript 4 Ã¼zerinde ciddi bir Ã§alÄ±ÅŸma yapÄ±lmasÄ±na raÄŸmen asla tamamlanamadÄ±, ancak beÅŸinci sÃ¼rÃ¼m iÃ§in Ã¶nemli bir ilham kaynaÄŸÄ± oldu. ECMAScript 5, 2009 yÄ±lÄ±nÄ±n AralÄ±k ayÄ±nda yayÄ±nlandÄ±. En son yayÄ±nlanan versiyonu ECMAScript 2020, Haziran 2020'de yayÄ±nladÄ±.

**ECMAScript VersiyonlarÄ±**

```
1. ES1 / ECMAScript 1 (Haziran 1997)
2. ES2 / ECMAScript 2 (Haziran 1998)
3. ES3 / ECMAScript 3 (AralÄ±k 1999)
- ES4 / ECMAScript 4 (YayÄ±nlanmadÄ±)
4. ES5 / ECMAScript 5 (AralÄ±k 2009)
5. ES5.1 / ECMAScript 5.1 (Haziran 2011)
6. ES6 / ECMAScript 2015 (Haziran 2015)
7. ES2016 / ECMAScript 2016 (Haziran 2016)
8. ES2017 / ECMAScript 2017 (Haziran 2017)
9. ES2018 / ECMAScript 2018 (Haziran 2018)
10. ES2019 / ECMAScript 2019 (Haziran 2019)
11. ES2020 / ECMAScript 2020 (Haziran 2020)
```

## 4.3-JavaScript KullanÄ±m AlanlarÄ±

JavaScript'in tarihi konusunda da belirteceÄŸimiz gibi, JavaScript'in ortaya Ã§Ä±kÄ±ÅŸ amacÄ± siteleri interaktif ve fonksiyonel hale getirmekti. Ancak ECMA StandartÄ± ile hÄ±zla deÄŸiÅŸen ve geliÅŸen JavaScript, yazÄ±lÄ±mcÄ±larÄ±n talepleri doÄŸrultusunda sÃ¼rekli Ã¼zerine koyarak ve yeni bir dÃ¶nem baÅŸlatan Node.js'in geliÅŸtirilmesiyle, oldukÃ§a Ã¶nemli gÃ¼ncellemeler de alarak her alanda kullanabilecek bir dil haline geldi. BÃ¶ylece tÃ¼m dÃ¼nyanÄ±n en Ã§ok kullanÄ±lan yazÄ±lÄ±m dili olarak son yÄ±llarda hep ilk sÄ±ralarda yer edinmeyi baÅŸardÄ±.

**JavaScript'in kullanÄ±labileceÄŸi alanlar:**

- Front-end
- Back-end
- Mobil (Mobile)
- MasaÃ¼stÃ¼ (Desktop)
- Oyun (Game)
- Makine Ã–ÄŸrenmesi, Derin Ã–ÄŸrenme ve Yapay Zeka (Machine Learning, Deep Learning & Artificial Intelligence)

## 4.4-DeÄŸiÅŸken (Variable) TanÄ±mlama

Programlama dillerinde sÄ±kÃ§a verileri bellek yani RAM de saklamamÄ±z gerekir. RAM iÅŸlem yapmak iÃ§in son derece hÄ±zlÄ± bir donanÄ±mdÄ±r.
BasitÃ§e, bellke iÃ§erisindeki bir alanÄ±n adlandÄ±rÄ±lmasÄ±na ve ayrÄ±lmasÄ±na deÄŸiÅŸken tanÄ±mlamak denir.

- DeÄŸiÅŸken isimleri harf, \_ veya $ iÅŸareti ile baÅŸlayabilir. Fakat ES5 (ECMAScript 5) birlikte gelen Ã¶zellikle UNICODE kodlarÄ± kullanÄ±lÄ±rken kaÃ§Ä±ÅŸ karakteri olarak kullanÄ±lan \ iÅŸareti ilk karakter olarak kullanÄ±labilir.
- Ä°lk harften sonra deÄŸiÅŸken isimlerinde rakamlar da kullanÄ±labilir. $ ve \_ dÄ±ÅŸÄ±nda baÅŸka noktalama iÅŸaretleri kullanÄ±lamaz
- DeÄŸiÅŸken ismindeki harfler arasÄ±nda boÅŸluk kullanÄ±lamaz.

## 4.5-DeÄŸiÅŸkene DeÄŸer Atama ve Veri TÃ¼rleri

DeÄŸiÅŸkenlere deÄŸer atama = operatÃ¶rÃ¼ ile yapÄ±lÄ±r.  
JavaScript loosely typed bir programlama dilidir. Yani bir deÄŸiÅŸkeni tanÄ±mlarken deÄŸiÅŸkenin tÃ¼rÃ¼nÃ¼ (sayÄ±sal, metinsel, boolean) belirtmemize gerek yoktur.  
Bir deÄŸiÅŸkene aÅŸaÄŸÄ±daki veri tiplerini atayabiliriz.

- Boolean = MantÄ±ksal ifadedir. _true_ veya _false_ deÄŸeri atanabilir
- Number = SayÄ±sal ifadedir. 2^53 -1 deÄŸerine kadar sayÄ±sal deÄŸerler atanabilir.
- BigInt = 2^53-1 deÄŸerinden bÃ¼yÃ¼k deÄŸerleri atayabilir.
- String = Metinsel ifadelerdir. Metinsel ifade tanÄ±mlanÄ±rken ifade â€œ â€ veya â€˜ â€™ iÅŸaretleri arasÄ±na yazÄ±lÄ±r.
- Object = YukarÄ±da ki 7 veri tÃ¼rÃ¼ de primitive tiplidir. Objelerde ( nesne, dizi ) gibi referans tipler de deÄŸiÅŸkenlere atanabilir.

**var ile deÄŸiÅŸken tanÄ±mlama**
Global scope veya function scope'ta deklarasyon saÄŸlayamaya yarayan keyword'dur. Scope Ã¶zelliklerini daha sonra Ã¶rneklerle aÃ§Ä±klayacaÄŸÄ±z. var ile tanÄ±mlanan deÄŸiÅŸkenlerin Ã¶zellikleri ÅŸunlardÄ±r.

- DeÄŸiÅŸken deÄŸerleri deÄŸiÅŸtirilebilir.
- AynÄ± isimle tekrardan tanÄ±mlanabilirler.
- var ile tanÄ±mlanan deÄŸiÅŸkenler global scope veya function scope'tur. Global scope'ta tanÄ±mlanan deÄŸiÅŸkenlere her yerden ulaÅŸÄ±labilir. Function iÃ§erisinde tanÄ±mlanan deÄŸiÅŸkenlere ise tanÄ±mlÄ± olduÄŸu fonksiyonda ulaÅŸÄ±labilir.

**Anahtar Notlar :**  
ES6 ile birlikte var kullanÄ±mÄ± _decepricate_ olmuÅŸtur ve yerine _let_ ve _const_ gelmiÅŸtir. Bu keyword ler bize _var_ Ä±n saÄŸlayamadÄ±ÄŸÄ± Ã¶zellikleride saÄŸlamaktadÄ±r.

**let ile deÄŸiÅŸken tanÄ±mlama**
DeÄŸiÅŸkenleri block scope'ta tanÄ±mlayan deklarasyondur. let ile tanÄ±mlanan deÄŸiÅŸkenlerin Ã¶zellikleri ÅŸunlardÄ±r.

- DeÄŸiÅŸken deÄŸerleri deÄŸiÅŸtirilebilir.
- AynÄ± isimle tekrardan aynÄ± blokta tanÄ±mlanamaz. FarklÄ± block'larda aynÄ± isimle tanÄ±mlanabilir.

**const ile deÄŸiÅŸken tanÄ±mlama**
Block scope da tanÄ±mlÄ±, deÄŸeri sonradan deÄŸiÅŸtirilemez deÄŸiÅŸkenleri deklare etmek iÃ§in kullanÄ±lan keyword'dÃ¼r.

- Const ile tanÄ±mlanan objelerin Ã¶zellikleri (properties) deÄŸiÅŸtirilebilir fakat objenin kendisi deÄŸiÅŸtirilemez. Diziler iÃ§inde aynÄ±sÄ±
- geÃ§erlidir. Dizi deÄŸerleri deÄŸiÅŸtirilebilir fakat dizinin kendisi deÄŸiÅŸtirilemez.

## 4.6-Hoisting

DeÄŸiÅŸkenlerden bahsederken, deÄŸiÅŸkenleri kullanÄ±p daha sonra tanÄ±mlamamÄ±zÄ± saÄŸlayan hoisting kavramÄ±ndan da bahsetmemiz gerekir. JavaScriptâ€™te tanÄ±mlanan deÄŸiÅŸkenler yorumlanÄ±rken tanÄ±mladÄ±ÄŸÄ±nÄ±z deÄŸiÅŸkenler fonksiyon veya ifadenin yukarÄ±sÄ±na alÄ±narak yorumlanÄ±r. Buna hoisting (yukarÄ± alma) denir. YukarÄ±ya alÄ±nan deÄŸiÅŸkenler var ile deklare edildiyse atandÄ±klarÄ± deÄŸer yerine undefined deÄŸerini alÄ±r. let veya const ile deklare edildi ise ReferanceError hatasÄ± verir. let ve const ile deklare edilen deÄŸiÅŸkenler bloÄŸun baÅŸlangÄ±cÄ±ndan itibaren tanÄ±mÄ±nÄ±n yapÄ±ldÄ±ÄŸÄ± yere kadar kadar geÃ§ici (temporal dead zone) bÃ¶lgededir.

## 4.7- Javascript Veri TÃ¼rleri

Veri tÃ¼rleri her programlama dili iÃ§in oldukÃ§a Ã¶nemli bir kavramdÄ±r. Veri tÃ¼rÃ¼, deÄŸiÅŸkenler iÃ§inde saklanacak verinin tÃ¼rÃ¼ne gÃ¶re sÄ±nÄ±flandÄ±rÄ±lmasÄ± iÅŸlemidir.

JavaScript, C# veya Java gibi diÄŸer programa dillerine benzer veri tiplerini iÃ§erir. Genel olarak iki veri tÃ¼rÃ¼ olarak sÄ±nÄ±flandÄ±rabiliriz;

1- Ä°lkel (Primitive) Veri TÃ¼rleri

- String
- Number
- Boolean
- Undefined
- Null
- Symbol
- Bigint

2- Ä°lkel Olmayan (Reference) Veri TÃ¼rleri

- Object
- Array
- Function

JavaScript dinamik bir dildir, yani bir deÄŸiÅŸken herhangi bir zamanda herhangi bir veri tÃ¼rÃ¼nÃ¼ tutabilir. Ã–rneÄŸin :

```
var x = 100;
x = "javascript";
x = false;
x = null;
x = undefined;

alert(x); // undefined
```

x deÄŸiÅŸkeni en son atanmÄ±ÅŸ undefined deÄŸerini tutacaktÄ±r.

**typeof** operatÃ¶rÃ¼ ile bir deÄŸiÅŸkenin veri tipini Ã¶ÄŸrenebiliriz. EÄŸer ki object iÃ§indeki herhangi bir yapÄ±sal tipi kontrol etmek istersek, bunun iÃ§in _typeof_ kullanmak anlamsÄ±z olur, Ã§Ã¼nkÃ¼ her zaman â€œobjectâ€ Ã§Ä±ktÄ±sÄ±nÄ± alÄ±rÄ±z. Bu tarz bir durumda kesin bir sonuÃ§ alÄ±namasa da **instanceof** operatÃ¶rÃ¼nÃ¼ kullanmak mantÄ±klÄ± olabilir.

## 4.8-Number Veri TÃ¼rÃ¼ KullanÄ±mÄ±, Temel Aritmetik Ä°ÅŸlemler ve Ä°ÅŸlem Ã–nceliÄŸi ve ArttÄ±rma ve Azaltma Ä°ÅŸlemleri

**Number (SayÄ±) Veri TÃ¼rÃ¼**

JavaScript dili weakly-typed yani gÃ¼Ã§sÃ¼z tÃ¼rlÃ¼ bir dildir. DeÄŸiÅŸkenlerin ve parametrelerin tÃ¼rlerini bildirmek gerekmez. TÃ¼r kullanÄ±mdan dolaylÄ± olarak Ã§Ä±kartÄ±lÄ±r.  
Ã–rneÄŸin:

```
let x = 3;
```

ÅŸeklindeki tanÄ±mlamada deÄŸiÅŸkenin deÄŸeri tam sayÄ± (integer), aÅŸaÄŸÄ±daki Ã¶rnekte ise

```
let y = 3.14;
```

y deÄŸiÅŸkenin deÄŸer tÃ¼rÃ¼ kayan sayÄ± (float) tÃ¼rÃ¼ndedir. SayÄ±nÄ±n integer veya float olup olmadÄ±ÄŸÄ± nokta (.) olup olmamasÄ±ndan anlaÅŸÄ±lÄ±r.

**Aritmetik OperatÃ¶rler**

- Toplama: +
- Ã‡Ä±karma: -
- Ã‡arpma: \*
- Ãœs Alma: \*\*
- BÃ¶lme: /
- Mod Alma: %
- ArttÄ±rma: ++
- Eksiltme: --

**Toplama:** SayÄ±larÄ± toplama iÅŸlemini gerÃ§ekleÅŸtirir. Ä°ÅŸlem yÃ¶nÃ¼ soldan saÄŸadÄ±r.

```
    var result = 3+5;
    console.log(result);
    //8
```

**Ã‡Ä±karma:** Ä°ki sayÄ±yÄ± Ã§Ä±karma iÅŸlemini gerÃ§ekleÅŸtirir. Ä°ÅŸlem yÃ¶nÃ¼ soldan saÄŸadÄ±r.

```
    var result = 5-2;
    console.log(result);
    //3
```

**Ã‡arpma:** Ä°ki sayÄ±yÄ± Ã§arpma iÅŸlemini gerÃ§ekleÅŸtirir. Ä°ÅŸlem yÃ¶nÃ¼ soldan saÄŸadÄ±r.

```
    var result = 5*2;
    console.log(result);
    //10
```

**Ãœs Alma:** ECMAScript6 ile gelmiÅŸtir. Soldaki deÄŸerin, saÄŸdaki rakam veya sayÄ± baz alÄ±narak kendisiyle Ã§arpÄ±lmasÄ± ÅŸeklinde gerÃ§ekleÅŸir.

```
    var result = 5**2;
    console.log(result);
    //25
```

**BÃ¶lme:** Ä°ki sayÄ±yÄ± bÃ¶lme iÅŸlemini gerÃ§ekleÅŸtirir. Ä°ÅŸlem yÃ¶nÃ¼ soldan saÄŸadÄ±r.

```
    var result = 6/3;
    console.log(result);
    //2
```

**Mod Alma:** OperatÃ¶rÃ¼n solundaki deÄŸerin saÄŸdakine kalanÄ±nÄ± bulmak iÃ§in kullanÄ±lmaktadÄ±r. Ä°ÅŸlem yÃ¶nÃ¼ soldan saÄŸadÄ±r.

```
    var result = 6%3;
    console.log(result);
    //0
```

**Azaltma:** Bir sayÄ±yÄ± azaltmak iÃ§in kullanÄ±rÄ±z. DeÄŸeri 1 azaltÄ±r. For ve While dÃ¶ngÃ¼leri iÃ§inde sÄ±k sÄ±k kullanÄ±lÄ±r. ArttÄ±rma operatÃ¶rÃ¼nde anlatÄ±lan baÅŸa veya sonraya operatÃ¶r ekleme iÅŸlemi sonunda gerÃ§ekleÅŸen durum azaltma operatÃ¶rÃ¼ iÃ§inde geÃ§erlidir.

```
    let counter = 1;
    let a = --counter;
    alert(a); // 0
```

## 4.9-Boolean Veri TÃ¼rÃ¼

Program yazarken sadece iki ifade ile Ã§alÄ±ÅŸmak (evet yada hayÄ±r, _0_ yada _1_ gibi) programÄ±n anlaÅŸÄ±labilmesi ve yazÄ±m kolaylÄ±ÄŸÄ± aÃ§Ä±sÄ±ndan Ã§ok iÅŸimize yarar. Ä°ÅŸte bu veri tÃ¼rÃ¼nde ise iki ifade vardÄ±r. Bunlar _true_ ve _false_ tir.

```
Boolean(10>9); // true
```

```
Boolean(10>11); // false
```

```
const b1 = Boolean(100); // true
const b2 = Boolean(3.14); // true
const b3 = Boolean(-15); // true
const b4 = Boolean("Hello"); // true
const b5 = Boolean('false'); // true
const b6 = Boolean(1 + 7 + 3.14); // true
```

```
const c1 = Boolean(undefined); // false
const c2 = Boolean(null); // false
const c3 = Boolean(""); // false
const c4 = Boolean(false); // false
const c5 = Boolean(NaN); // false
const c6 = Boolean(0); // false
const c6 = Boolean(-0); // false
```

## 4.10-DeÄŸiÅŸken TÃ¼rÃ¼nÃ¼ Kontrol Etme

Ã‡alÄ±ÅŸtÄ±ÄŸÄ±mÄ±z veriler her zaman kodumuz iÃ§in uygun olmayabilir. Verilerin kontrolÃ¼nÃ¼ saÄŸlayÄ±p ona uygun kod yazabiliriz veya istediÄŸimiz tÃ¼re dÃ¶nÃ¼ÅŸtÃ¼rerek ilerleyebiliriz.

Bu kontrolleri yaparken sÄ±kÃ§a _typeof_ kullanÄ±lÄ±r.

```
console.log(typeof 42);
// beklenen output: "number"

console.log(typeof 'kodluyoruz');
//beklenen output: "string"

console.log(typeof true);
// beklenen output: "boolean"

console.log(typeof Variable);
// beklenen output: "undefined"
```

**Anahtar Notlar :**
Bir baÅŸka ÅŸekilde isInteger( ), isFinite( ) veya isNaN( ) kullanarak da kontrol saÄŸlayabiliriz.

```
//isInteger( ) yÃ¶ntemi, sayÄ±larÄ±n tam sayÄ± olup olmadÄ±ÄŸÄ±nÄ± belirler.
Number.isInteger(123) //true
Number.isInteger(-123) //true
Number.isInteger(0.5) //false
//isFinite () yÃ¶ntemi, bir deÄŸerin sonlu bir sayÄ± olup olmadÄ±ÄŸÄ±nÄ± belirler.
Number.isFinite(0) //true
Number.isFinite('123') //false
Number.isFinite('Hello') //false
Number.isFinite(-Infinity) //false
Number.isFinite(0 / 0) //false
// Number.isNaN () yÃ¶ntemi, bir deÄŸerin NaN (Not-A-Number) olup olmadÄ±ÄŸÄ±nÄ± belirler.

Number.isNaN(123) //false
Number.isNaN(0) //false
Number.isNaN('123') //false
Number.isNaN('Hello') //false
Number.isNaN('') //false
Number.isNaN(true) //false
Number.isNaN(undefined) //false
Number.isNaN('NaN') //false
Number.isNaN(NaN) //true
```

## 4.11-DeÄŸiÅŸken TÃ¼rÃ¼nÃ¼ DeÄŸiÅŸtirmek (Type Coercion)

Type Coercion; bir deÄŸiÅŸkenin tÃ¼rÃ¼nÃ¼, baÅŸka bir deÄŸiÅŸkene dÃ¶nÃ¼ÅŸtÃ¼rmeye yarayan yÃ¶ntemdir. Ä°ki tipi vardÄ±r. Bunlar explicit ve implicit dÃ¶nÃ¼ÅŸÃ¼mlerdir. Explicit iÃ§in metodlarla yapÄ±lan dÃ¶nÃ¼ÅŸÃ¼m denilebilir. Implicit ise operatÃ¶rler ile veya Javascript in kendi yaptÄ±ÄŸÄ± dÃ¶nÃ¼ÅŸÃ¼m diyebiliriz.

**Explicit Coercion**

```
String(123) // â€œ123â€
ParseInt(â€œ123â€) // 12
```

**Implicit Coercion**

```
If(3<5) // true
console.log(â€˜ â€™+123) // â€œ123â€
12/â€6â€ // 2
```

**String DÃ¶nÃ¼ÅŸÃ¼mÃ¼**

Bir deÄŸeri string e dÃ¶nÃ¼ÅŸtermek iÃ§in String() fonksiyonu kullanÄ±lÄ±r. Binary (kili) ifatede _+_ operatÃ¶rÃ¼ birstring ifadeye uygulandÄ±ÄŸÄ±nda ise implicit dÃ¶nÃ¼ÅŸÃ¼m tetiklenir.

```
String(123) // â€œ123â€ explicit
123 + ''    // â€œ123â€    implicit
```

**NOTLAR:**
Symbolâ€™de durum biraz farklÄ±dÄ±r, Ã§Ã¼nkÃ¼ dÃ¶nÃ¼ÅŸÃ¼m sadece explicit bir ÅŸekilde yapÄ±labilir, implicit bir ÅŸekilde yapÄ±lamaz.

```
String(Symbol('my symbol')) // 'Symbol(my symbol)'
'' + Symbol('my symbol') // TypeError is thrown
```

**Boolean DÃ¶nÃ¼ÅŸÃ¼mÃ¼**  
Bir deÄŸeri explicit boolean a dÃ¶nÃ¼ÅŸtÃ¼rmek iÃ§in Boolean() metodu kullanÄ±lÄ±r.  
Ä°mplicit coercion dÃ¶nÃ¼ÅŸÃ¼m ise mantÄ±ksal operatÃ¶rlerin kullanÄ±ldÄ±ÄŸÄ±nda tetiklenir.

```
Boolean(2) // explicit
var a=!!2 //explicit
if (2) { ... } // implicit due to logical context
!!2 // implicit due to logical operator
2 || 'hello' // implicit due to logical operator
```

**Ã–rekler**

```
Boolean('') // false
Boolean(0) // false
Boolean(-0) // false
Boolean(NaN) // false
Boolean(null) // false
Boolean(undefined) // false
Boolean(false) // false

Boolean({}) // true
Boolean([]) // true
Boolean(Symbol()) // true
!!Symbol() // true
Boolean(function() {}) // true
```

**Nesneler (Objects) iÃ§in Type Coercion**
Javascript te nesneler referans tipler olduÄŸundan Ã¼zerlerinde deÄŸiÅŸiklik yapmak biraz zordur. DeÄŸiÅŸiklik yapabilmemiz iÃ§in elimizde primitif tip olmasÄ± gerekir. Yani referans tipler primitif tiplere zorlanÄ±r. Primitif olmayan herhangi bir deÄŸer yada obje (object veya array) dolu yada boÅŸ farketmez true deÄŸere dÃ¶necektir.

```
console.log(Boolean({})) // true
console.log(Boolean([])) // true
console.log(Boolean([1,2,3])) // true
console.log(Boolean({13:234})) //true
```

## 4.12-Template Literals KullanÄ±mÄ±

Template literals (Ã¶neki adÄ± template Strings), kod okunabilirliÄŸi ve yazÄ±m kolaylÄ±ÄŸÄ± saÄŸlayan ES6 ile gelmiÅŸ bir string yazma ÅŸeklidir.

**SaÄŸladÄ±ÄŸÄ± faydalar**

- Ã‡ok satÄ±rlÄ± dize yazÄ±mÄ±

```
//Eski kullanÄ±m:
let eskiString = "En sevdiÄŸim yemekler:\nÄ°skender\nMantÄ±"

//Yeni kullanÄ±m:
let yeniString = `En sevdiÄŸim yemekler:
Ä°skender
MantÄ±`
```

- Ä°nterpolasyon : metin iÃ§erisinde deÄŸiÅŸken kullanmak anlamÄ±na gelir.

```
let ad= `Ziya`;
let soyad= `Ã‡AYLAN`;

//Eski kullanÄ±m
console.log("Benim adÄ±m "+ad+" "+ soyad);

//Yeni kullanÄ±m
console.log(`Benim adÄ±m ${ad} ${soyad}`);
```

- Html ÅablonlarÄ± : Ã‡ok satÄ±rlÄ± dizeleri kolaylÄ±kla kullanmak ve dizelerimize iÃ§erik eklemek iÃ§in de Template Literalâ€™den faydalanabiliriz.

```
//DeÄŸiÅŸkenlerimizi tanÄ±mlayalÄ±m
const ad =`Ziya`
const soyad =`Ã‡AYLAN`
const gozRengi =`Kahverengi`
const yas =39


const kisi = `
<p>${ad}</>
<p>${soyad}</>
<p>${gozRengi}</>
<p>${yas}</>
`;

document.body.innerHTML = kisi;

//Bu kullanÄ±m daha az karmaÅŸÄ±k ve okunabilir.
```

**KÄ±saca FaydalarÄ±nÄ± sÄ±ralarsak**

- Kod okunabilirliÄŸini kolaylaÅŸtÄ±rÄ±r
- String ifadeler iÃ§erisinde deÄŸiÅŸken yazma kolaylÄ±ÄŸÄ± saÄŸlar,
- Åablon etiketlerini daha karmaÅŸÄ±k hale getirir.

[Linkteki Ã¶rneÄŸi inceleyiniz.](./Javascript-Dersleri/template-literal-example/template-literal.js). Ã–rnekte template literal kullanÄ±larak web sayfasÄ±nda kitaplar listelenmiÅŸtir.

## 4.13-String Veri TÃ¼rÃ¼ Ä°ÅŸlemleri

**String nedir ?**

Javascript e metinlerin tÃ¼mÃ¼ _string_ veri tipinde tutulur.

**Length Ã–zelliÄŸi**

String ifadenin uzunluÄŸunu bize verir. AÅŸaÄŸÄ±daki Ã¶rneÄŸi inceleyiniz.

```
const str = "javascript";
// bu ifadenin sonucu konsol ekranÄ±nda 10 olarak gÃ¶rÃ¼ntÃ¼lenecektir.
console.log(str.length);
```

**indexOf Ã–zelliÄŸi**

Metin iÃ§erisinde arama yapmak istediÄŸimizde bize aradÄ±ÄŸÄ±mÄ±z deÄŸerin index numarasÄ±nÄ± verir.

```
const str = "Ziya Ã§aylan";
// 'ya' nÄ±n baÅŸladÄ±ÄŸÄ± index numarasÄ±nÄ± geri dÃ¶ner yani 2
console.log(str.indexOf("ya"));
```

**lastIndexOf Ã–zelliÄŸi**

indexOf ile aynÄ± Ã§alÄ±ÅŸÄ±r ancak arasÄ±ndaki fark; metin iÃ§erisinde arama yapmak istediÄŸimizde aradÄ±ÄŸÄ±mÄ±z deÄŸerin en son karÅŸÄ±laÅŸtÄ±ÄŸÄ± index numarasÄ±nÄ± geri dÃ¶ner. AÅŸaÄŸÄ±daki Ã¶rnekte olduÄŸu gibi

```
const str = "Ziya Ã§aylan";
// 'a' nÄ±n en son gÃ¶rÃ¼ldÃ¼ÄŸÃ¼ index numarasÄ±nÄ± geri dÃ¶ner yani 9
console.log(str.indexOf("a"));
```

**Search - Metin Ä°Ã§erisinde Arama Yapma**

indexOf ile aynÄ± ÅŸekilde Ã§alÄ±ÅŸÄ±r ve _"Regular Expressions"_ iÅŸlemlerinde Ã§ok kullanÄ±lmaktadÄ±r.

```
const str = "Ziya Ã§aylan";
// 'ya' index numarasÄ±nÄ± geri dÃ¶ner yani 2
console.log(
  `Search ile "ya" yÄ± aradÄ±ÄŸÄ±mÄ±zda geri dÃ¶nen deÄŸer ${str.search("ya")}`  // konsolda : Search ile "ya" yÄ± aradÄ±ÄŸÄ±mÄ±zda geri dÃ¶nen deÄŸer 2
);
```

**Slice - Metinden ParÃ§a Alma**

- Bu metod ile metinden bir parÃ§a almak istediÄŸimizde almak istediÄŸimiz yerin index numarasÄ±nÄ± vererek alabiliriz.

```
const str = "Ziya Ã§aylan";

console.log(str.slice(2, 4)); // 2. index numarasÄ±ndan baÅŸlar ve 4. index numarasÄ±na kadar alÄ±r ancak 4. index dahil deÄŸildir.
```

- slice metoduna tek parametre verdiÄŸimizde ise; verdiÄŸimiz parametreden baÅŸlar ve metinin sununa kadar alÄ±r

```
const str = "Ziya Ã§aylan";

console.log(str.slice(2)); // 2. index numarasÄ±ndan baÅŸlar ve sona kadar alÄ±r Konsolda : ya Ã§aylan
```

- index numarasÄ± hiÃ§ yazmaz isek metini komple alÄ±r.

**Replace - Metodu (Metin bulma ve deÄŸiÅŸtirme)**

AradÄ±ÄŸÄ±mz metini bulmamÄ±zÄ± ve istediÄŸimiz metin ile deÄŸiÅŸtirmemizi saÄŸlar.

```
const str = "Ziya Ã§aylan";

console.log(str.replace("Ã§aylan", "Ã‡AYLAN")); // ""Ã§aylan metinini bulur ver onun yerine "Ã‡AYLAN" yazar
```

**toUpperCase ve toLowerCase**

- toUpperCase ile metin bÃ¼yÃ¼k harfe Ã§evrilir.
- toLowerCase ile de metin tamamÄ± kÃ¼Ã§Ã¼k harfe Ã§evrilir.

```
const str = "Ziya Ã§aylan";

console.log(str.toUpperCase()); // ZIYA Ã‡AYLAN
console.log(str.toLocaleLowerCase()); // ziya Ã§aylan
```

**Concat - Metin BirleÅŸtirme**

- Elimizdeki iki string tÃ¼rÃ¼nden veriyi birleÅŸtirmemize olanak saÄŸlar

```
const myName = "ziya";
const surname = "Ã§aylan";

console.log(myName.concat(" ", surname)); //myName den sonra belirttiÄŸimiz gibi " " (bir boÅŸluk bÄ±rakÄ±r ve surname i ekler) konsolda : ziya Ã§aylan
```

**charAt- Ä°ndex NumarasÄ±na GÃ¶re Karakter Bulmak**

- BelirttiÄŸimiz index numarasÄ±ndaki karakteri geri dÃ¶ndÃ¼rÃ¼r.

```
const str = "Ziya Ã§aylan";

console.log(str.charAt(2)); // y
console.log(str.charAt(3)); // a
```

**charCodeAt â€“ Ä°ndex NumarasÄ±na GÃ¶re Karakterin Unicode DeÄŸerini Bulma**

- BelirttiÄŸimiz index numarasÄ±ndaki karakterin Unicode deÄŸerini geri dÃ¶ndÃ¼rÃ¼r.

```
const str = "Ziya Ã§aylan";

console.log(str.charCodeAt(2)); // 121
```

**Split â€“ Metni Diziye Ã‡evirme**

- splite metodu ile metin diziye Ã§evrilebilir.
- KullanÄ±lan parametre ile de metinin nasÄ±l parÃ§alanacaÄŸÄ± belirlenir.

```
const str = "Ziya Ã§aylan";

const isimler = str.split(" ");
console.log(isimler); // [ 'Ziya', 'Ã§aylan' ]

const metin = "ziya-ali-veli-hasan-hÃ¼seyin-mehmet-mahmut-canan-caner-eda-seda";
console.log(metin.split("-")); // ['ziya','ali','veli','hasan','hÃ¼seyin','mehmet','mahmut','canan','caner','eda','seda']
```

[Linkteki string Ã¶rneklerini inceleyiniz.](./Javascript-Dersleri/string-ozellikleri/string.js).

**BazÄ± Ã–rnekler**

```
// istenilen karakterden sonrasÄ±nÄ± alma
// Ã–rnek --> ziyacaylan@gmail.com
// '@' iÅŸaretinden sonraki karakterleri alma

const email = "ziyacaylan@gmail.com";

const domain = email.slice(email.search("@") + 1);
console.log(domain);  // gmail.com

const userName = email.slice(0, email.search("@"));
console.log(userName);  // ziyacaylan
```

## 4.14-Document Object Model (DOM) Nedir ?

- 3C (World Wide Web Consortium) a gÃ¶re DOM programlarÄ±n ve komut dosyalarÄ±nÄ±n bir belge iÃ§eriÄŸine yapÄ±sÄ±na ve stiline dinamik olarak eriÅŸmesine ve gÃ¼ncellemesine izin veren bir platform ve dilden baÄŸÄ±msÄ±z bir arayÃ¼zdÃ¼r.
- HTML yapÄ±sÄ±nÄ± daha Ã¶nce incelemiÅŸtik. TarayÄ±cÄ±nÄ±n belgeyi temsil etmek iÃ§in kullandÄ±ÄŸÄ± veri yapÄ±sÄ± bu ÅŸekli izler.Her kutu iÃ§in, hangi HTML etiketini temsil ettiÄŸi ve hangi kutularÄ± ve metni iÃ§erdiÄŸi gibi ÅŸeyleri bulmak iÃ§in etkileÅŸime girebileceÄŸimiz bir nesne vardÄ±r. Bu temsil, **Document Object Model** veya kÄ±saca **DOM** olarak adlandÄ±rÄ±lÄ±r.
- DOM bir aÄŸaÃ§ dizini gibi bÃ¼tÃ¼n dokÃ¼manlarÄ± birbirine baÄŸlar.  
  ![DOM](./Javascript-Dersleri/assets/dom.jpg)

  [Linkteki Ã¶rnekleri inceleyiniz.](./Javascript-Dersleri/dom/index.html)

**DOM iÃ§erisinden Etiket ve ID ile Ã–ÄŸe SeÃ§imi**

- document objesinin getElemntById() metodu kullanÄ±larak sayfadaki html elementlerinin ID leri referans alÄ±narak seÃ§im iÅŸlemi yapÄ±labilir.
- ID'ler bÃ¼yÃ¼k-kÃ¼Ã§Ã¼k harf duyarlÄ±dÄ±r. Bu sayede HTML document iÃ§inde biriciklik gÃ¶sterir ve her zaman geriye bir eleman dÃ¶ndÃ¼rÃ¼r. Bir eÅŸleÅŸme bulamazsa da geriye _null_ dÃ¶nÃ¼ÅŸÃ¼nÃ¼ yapar.

```
document.getElementById('#root'); // null
document.getElementById('root'); // <section id=â€‹"root">â€‹â€¦â€‹</section>â€‹
```

**Get Elements By Tag Name**

- ElemanlarÄ± etiket isimlerine gÃ¶re seÃ§mek iÃ§in document objesinin _getElemntByTagName()_ metodu kullanÄ±lÄ±r.
- Genelde birden Ã§ok elemana ulaÅŸmak iÃ§in kullanÄ±lÄ±r.
- Girdi olarak bir _html elementi_ alÄ±r ve geriye bir _HTMLCollection_ dÃ¶ndÃ¼rÃ¼r.

**Get Elements By Name**

- ElemanlarÄ± isimleri gÃ¶re getirmek iÃ§in document objesinin _getElementByName()_ metodu kullanÄ±lÄ±r.
- ElemanlarÄ± name deÄŸerlerine gÃ¶re bir _NodeList objesi_ dÃ¶ndÃ¼rÃ¼r.

```
<input type="text" name="e-posta">
<input type="tel" name="telefon">
<input type="date" name="tarih">
```

telefon adÄ±nÄ± taÅŸÄ±yan elemanlarÄ± getirelim

```
const tel = document.getElementsByName('telefon');
console.log(tel) // NodeListÂ [input]
```

**Get Elements By Class Name**

- DOM da istediÄŸimiz class name e sahip olan elementleri seÃ§mek iÃ§in _getElemntByClassName()_ metodu kullanÄ±lÄ±r.
- Bu metodda bize HTMLCollection dÃ¶ndÃ¼rÃ¼r.
- KullanÄ±rken class name baÅŸÄ±na **nokta** _"."_ koymalÄ±yÄ±z.

```
    <div class="baykuÅŸ kusu">ğŸ¦‰</div>
    <div class="guvercin kusu">ğŸ¦</div>
    <div class="kartal kusu">ğŸ¦…</div>
    <div class="kedi">ğŸ±</div>
```

```
    //Get Elements By Class Name
    const kuslar = document.getElementsByClassName("kusu");
    console.log(kuslar); // HTMLCollection(3)Â [div.baykuÅŸ.kusu, div.guvercin.kusu, div.kartal.kusu]
```

**Query Selector**

- QuerySelector () yÃ¶ntemi, css seÃ§icilere baÄŸlÄ± olarak DOM da html elemanlarÄ±nÄ± seÃ§memize olanak saÄŸlayan iki modern javascript yÃ¶nteminden biridir.
- Bu yÃ¶ntem ile elementlerin hem class larÄ±nÄ± hemde id lerini kullanabiliriz.
- Bunu yaparken classlarÄ±n Ã¶nÃ¼ne "." id lerin Ã¶nÃ¼ne ise "#" kullanmamÄ±z gerekir.
- Sayfada ilk eÅŸleÅŸen eleman Ä± geriye dÃ¶ndÃ¼rÃ¼r.
- Belirtilen eleman ile eÅŸleÅŸmez ise geriye _null_ dÃ¶necektir.

**Query Selector All**

- querySelectorAll() metodu, QuerySelector () metodu ile aynÄ± mantÄ±k ile Ã§alÄ±ÅŸÄ±r tek farkÄ± eÅŸleÅŸen ilk elamanÄ± dÃ¶ndÃ¼rmek yerine eÅŸleÅŸen tÃ¼m elemanlarÄ± bir NodeList objesi olarak dÃ¶ndÃ¼rmesidir.
