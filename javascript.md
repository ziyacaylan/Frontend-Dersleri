# <img src="https://img.shields.io/badge/HTML5-E34F26?style=for-the-badge&logo=html5&logoColor=white"/> <img src="https://img.shields.io/badge/CSS3-1572B6?style=for-the-badge&logo=css3&logoColor=white"/> <img src="https://img.shields.io/badge/JavaScript-323330?style=for-the-badge&logo=javascript&logoColor=F7DF1E"/> <img src="https://img.shields.io/badge/Bootstrap-563D7C?style=for-the-badge&logo=bootstrap&logoColor=white" /> <img src="https://img.shields.io/badge/Font_Awesome-339AF0?style=for-the-badge&logo=fontawesome&logoColor=white" />

# Ä°Ã‡Ä°NDEKÄ°LER

---

## 4. Javascript Dersleri

## 4.1-Javascript Nedir?

Javascript web programlama alanÄ±nda yaygÄ±n olarak kullanÄ±lan dinamik bir programlama dilidir. EtkileÅŸimli ve dinamik web sayfalarÄ± geliÅŸtirmeye yardÄ±mcÄ± olur. Ä°sminden dolayÄ± Java programala dili ile karÄ±ÅŸtÄ±rÄ±lÄ±r ancak her iki dilde birbirinden Ã§ok farklÄ± birer dildir. AralarÄ±ndaki benzerlik; yazÄ±m ÅŸekli ve standart kÃ¼tÃ¼phanelerÄ± dÄ±ÅŸÄ±nda bir baÄŸlantÄ± yoktur.

C programlama dilinden tÃ¼retilmiÅŸ, semantiÄŸi ve tasarÄ±mÄ± ise Self ve Sheme programlama dillerinden esinlenmiÅŸtir.

Javascript dili 1997 yÄ±lÄ±nda Netscape ÅŸirketinde Ã§alÄ±ÅŸan Brendan Eich tarafÄ±ndan gliÅŸtirilmiÅŸtir. Ä°lk Ã§Ä±ktÄ±ÄŸÄ± yÄ±llarda o deneme iat web tarayÄ±cÄ±larÄ±n bÃ¼yÃ¼k Ã§oÄŸunluÄŸu tarafÄ±ndan yorumlanamÄ±yordu ancak Brendan Eich bu dili geliÅŸtirmeye devam etti.Brendan Eich o dÃ¶nemlerde Mozilla VakfÄ±â€™nÄ± kurdu. Bu vakÄ±f gÃ¼nÃ¼mÃ¼zde hÃ¢lÃ¢ Javascript dilini geliÅŸtirmeye devam etmektedir.

### 4.2-ECMAScript'in Ortaya Ã‡Ä±kÄ±ÅŸÄ±

1996 yÄ±lÄ±nÄ±n kasÄ±m ayÄ±nda Netscape firmasÄ± Javascript'in endÃ¼stri standardÄ± olarak belirlenmesi amacÄ±yla ECMA International'a (Avrupa Bilgisayar Ãœreticileri BirliÄŸi) baÅŸvuruda bulunduÄŸunu ilan etti. Bunun sonucunda standardize edilen sÃ¼rÃ¼m ECMAJcript olarak isimlendirildi ve 1997 yÄ±lÄ±nÄ±n haziran ayÄ±nda ECMA International, ECMA-262 standartlarÄ± Ã§erÃ§evesinde ilk sÃ¼rÃ¼m ECMAScript (kÄ±saca ES) yanÄ±mlandÄ±.Haziran 1998'de ISO/IEC-16262 standardÄ±na uyumlu hale getirilecek deÄŸiÅŸiklikler yapÄ±larak ECMAScript 2, AralÄ±k 1999'da ise ECMAScript 3 yayÄ±nlandÄ±.

ECMAScript 4 Ã¼zerinde ciddi bir Ã§alÄ±ÅŸma yapÄ±lmasÄ±na raÄŸmen asla tamamlanamadÄ±, ancak beÅŸinci sÃ¼rÃ¼m iÃ§in Ã¶nemli bir ilham kaynaÄŸÄ± oldu. ECMAScript 5, 2009 yÄ±lÄ±nÄ±n AralÄ±k ayÄ±nda yayÄ±nlandÄ±. En son yayÄ±nlanan versiyonu ECMAScript 2020, Haziran 2020'de yayÄ±nladÄ±.

**ECMAScript VersiyonlarÄ±**

```
1. ES1 / ECMAScript 1 (Haziran 1997)
2. ES2 / ECMAScript 2 (Haziran 1998)
3. ES3 / ECMAScript 3 (AralÄ±k 1999)
- ES4 / ECMAScript 4 (YayÄ±nlanmadÄ±)
4. ES5 / ECMAScript 5 (AralÄ±k 2009)
5. ES5.1 / ECMAScript 5.1 (Haziran 2011)
6. ES6 / ECMAScript 2015 (Haziran 2015)
7. ES2016 / ECMAScript 2016 (Haziran 2016)
8. ES2017 / ECMAScript 2017 (Haziran 2017)
9. ES2018 / ECMAScript 2018 (Haziran 2018)
10. ES2019 / ECMAScript 2019 (Haziran 2019)
11. ES2020 / ECMAScript 2020 (Haziran 2020)
```

## 4.3-JavaScript KullanÄ±m AlanlarÄ±

JavaScript'in tarihi konusunda da belirteceÄŸimiz gibi, JavaScript'in ortaya Ã§Ä±kÄ±ÅŸ amacÄ± siteleri interaktif ve fonksiyonel hale getirmekti. Ancak ECMA StandartÄ± ile hÄ±zla deÄŸiÅŸen ve geliÅŸen JavaScript, yazÄ±lÄ±mcÄ±larÄ±n talepleri doÄŸrultusunda sÃ¼rekli Ã¼zerine koyarak ve yeni bir dÃ¶nem baÅŸlatan Node.js'in geliÅŸtirilmesiyle, oldukÃ§a Ã¶nemli gÃ¼ncellemeler de alarak her alanda kullanabilecek bir dil haline geldi. BÃ¶ylece tÃ¼m dÃ¼nyanÄ±n en Ã§ok kullanÄ±lan yazÄ±lÄ±m dili olarak son yÄ±llarda hep ilk sÄ±ralarda yer edinmeyi baÅŸardÄ±.

**JavaScript'in kullanÄ±labileceÄŸi alanlar:**

- Front-end
- Back-end
- Mobil (Mobile)
- MasaÃ¼stÃ¼ (Desktop)
- Oyun (Game)
- Makine Ã–ÄŸrenmesi, Derin Ã–ÄŸrenme ve Yapay Zeka (Machine Learning, Deep Learning & Artificial Intelligence)

## 4.4-DeÄŸiÅŸken (Variable) TanÄ±mlama

Programlama dillerinde sÄ±kÃ§a verileri bellek yani RAM de saklamamÄ±z gerekir. RAM iÅŸlem yapmak iÃ§in son derece hÄ±zlÄ± bir donanÄ±mdÄ±r.
BasitÃ§e, bellke iÃ§erisindeki bir alanÄ±n adlandÄ±rÄ±lmasÄ±na ve ayrÄ±lmasÄ±na deÄŸiÅŸken tanÄ±mlamak denir.

- DeÄŸiÅŸken isimleri harf, \_ veya $ iÅŸareti ile baÅŸlayabilir. Fakat ES5 (ECMAScript 5) birlikte gelen Ã¶zellikle UNICODE kodlarÄ± kullanÄ±lÄ±rken kaÃ§Ä±ÅŸ karakteri olarak kullanÄ±lan \ iÅŸareti ilk karakter olarak kullanÄ±labilir.
- Ä°lk harften sonra deÄŸiÅŸken isimlerinde rakamlar da kullanÄ±labilir. $ ve \_ dÄ±ÅŸÄ±nda baÅŸka noktalama iÅŸaretleri kullanÄ±lamaz
- DeÄŸiÅŸken ismindeki harfler arasÄ±nda boÅŸluk kullanÄ±lamaz.

## 4.5-DeÄŸiÅŸkene DeÄŸer Atama ve Veri TÃ¼rleri

DeÄŸiÅŸkenlere deÄŸer atama = operatÃ¶rÃ¼ ile yapÄ±lÄ±r.  
JavaScript loosely typed bir programlama dilidir. Yani bir deÄŸiÅŸkeni tanÄ±mlarken deÄŸiÅŸkenin tÃ¼rÃ¼nÃ¼ (sayÄ±sal, metinsel, boolean) belirtmemize gerek yoktur.  
Bir deÄŸiÅŸkene aÅŸaÄŸÄ±daki veri tiplerini atayabiliriz.

- Boolean = MantÄ±ksal ifadedir. _true_ veya _false_ deÄŸeri atanabilir
- Number = SayÄ±sal ifadedir. 2^53 -1 deÄŸerine kadar sayÄ±sal deÄŸerler atanabilir.
- BigInt = 2^53-1 deÄŸerinden bÃ¼yÃ¼k deÄŸerleri atayabilir.
- String = Metinsel ifadelerdir. Metinsel ifade tanÄ±mlanÄ±rken ifade â€œ â€ veya â€˜ â€™ iÅŸaretleri arasÄ±na yazÄ±lÄ±r.
- Object = YukarÄ±da ki 7 veri tÃ¼rÃ¼ de primitive tiplidir. Objelerde ( nesne, dizi ) gibi referans tipler de deÄŸiÅŸkenlere atanabilir.

**var ile deÄŸiÅŸken tanÄ±mlama**
Global scope veya function scope'ta deklarasyon saÄŸlayamaya yarayan keyword'dur. Scope Ã¶zelliklerini daha sonra Ã¶rneklerle aÃ§Ä±klayacaÄŸÄ±z. var ile tanÄ±mlanan deÄŸiÅŸkenlerin Ã¶zellikleri ÅŸunlardÄ±r.

- DeÄŸiÅŸken deÄŸerleri deÄŸiÅŸtirilebilir.
- AynÄ± isimle tekrardan tanÄ±mlanabilirler.
- var ile tanÄ±mlanan deÄŸiÅŸkenler global scope veya function scope'tur. Global scope'ta tanÄ±mlanan deÄŸiÅŸkenlere her yerden ulaÅŸÄ±labilir. Function iÃ§erisinde tanÄ±mlanan deÄŸiÅŸkenlere ise tanÄ±mlÄ± olduÄŸu fonksiyonda ulaÅŸÄ±labilir.

**Anahtar Notlar :**  
ES6 ile birlikte var kullanÄ±mÄ± _decepricate_ olmuÅŸtur ve yerine _let_ ve _const_ gelmiÅŸtir. Bu keyword ler bize _var_ Ä±n saÄŸlayamadÄ±ÄŸÄ± Ã¶zellikleride saÄŸlamaktadÄ±r.

**let ile deÄŸiÅŸken tanÄ±mlama**
DeÄŸiÅŸkenleri block scope'ta tanÄ±mlayan deklarasyondur. let ile tanÄ±mlanan deÄŸiÅŸkenlerin Ã¶zellikleri ÅŸunlardÄ±r.

- DeÄŸiÅŸken deÄŸerleri deÄŸiÅŸtirilebilir.
- AynÄ± isimle tekrardan aynÄ± blokta tanÄ±mlanamaz. FarklÄ± block'larda aynÄ± isimle tanÄ±mlanabilir.

**const ile deÄŸiÅŸken tanÄ±mlama**
Block scope da tanÄ±mlÄ±, deÄŸeri sonradan deÄŸiÅŸtirilemez deÄŸiÅŸkenleri deklare etmek iÃ§in kullanÄ±lan keyword'dÃ¼r.

- Const ile tanÄ±mlanan objelerin Ã¶zellikleri (properties) deÄŸiÅŸtirilebilir fakat objenin kendisi deÄŸiÅŸtirilemez. Diziler iÃ§inde aynÄ±sÄ±
- geÃ§erlidir. Dizi deÄŸerleri deÄŸiÅŸtirilebilir fakat dizinin kendisi deÄŸiÅŸtirilemez.

## 4.6-Hoisting

DeÄŸiÅŸkenlerden bahsederken, deÄŸiÅŸkenleri kullanÄ±p daha sonra tanÄ±mlamamÄ±zÄ± saÄŸlayan hoisting kavramÄ±ndan da bahsetmemiz gerekir. JavaScriptâ€™te tanÄ±mlanan deÄŸiÅŸkenler yorumlanÄ±rken tanÄ±mladÄ±ÄŸÄ±nÄ±z deÄŸiÅŸkenler fonksiyon veya ifadenin yukarÄ±sÄ±na alÄ±narak yorumlanÄ±r. Buna hoisting (yukarÄ± alma) denir. YukarÄ±ya alÄ±nan deÄŸiÅŸkenler var ile deklare edildiyse atandÄ±klarÄ± deÄŸer yerine undefined deÄŸerini alÄ±r. let veya const ile deklare edildi ise ReferanceError hatasÄ± verir. let ve const ile deklare edilen deÄŸiÅŸkenler bloÄŸun baÅŸlangÄ±cÄ±ndan itibaren tanÄ±mÄ±nÄ±n yapÄ±ldÄ±ÄŸÄ± yere kadar kadar geÃ§ici (temporal dead zone) bÃ¶lgededir.

## 4.7- Javascript Veri TÃ¼rleri

Veri tÃ¼rleri her programlama dili iÃ§in oldukÃ§a Ã¶nemli bir kavramdÄ±r. Veri tÃ¼rÃ¼, deÄŸiÅŸkenler iÃ§inde saklanacak verinin tÃ¼rÃ¼ne gÃ¶re sÄ±nÄ±flandÄ±rÄ±lmasÄ± iÅŸlemidir.

JavaScript, C# veya Java gibi diÄŸer programa dillerine benzer veri tiplerini iÃ§erir. Genel olarak iki veri tÃ¼rÃ¼ olarak sÄ±nÄ±flandÄ±rabiliriz;

1- Ä°lkel (Primitive) Veri TÃ¼rleri

- String
- Number
- Boolean
- Undefined
- Null
- Symbol
- Bigint

2- Ä°lkel Olmayan (Reference) Veri TÃ¼rleri

- Object
- Array
- Function

JavaScript dinamik bir dildir, yani bir deÄŸiÅŸken herhangi bir zamanda herhangi bir veri tÃ¼rÃ¼nÃ¼ tutabilir. Ã–rneÄŸin :

```
var x = 100;
x = "javascript";
x = false;
x = null;
x = undefined;

alert(x); // undefined
```

x deÄŸiÅŸkeni en son atanmÄ±ÅŸ undefined deÄŸerini tutacaktÄ±r.

**typeof** operatÃ¶rÃ¼ ile bir deÄŸiÅŸkenin veri tipini Ã¶ÄŸrenebiliriz. EÄŸer ki object iÃ§indeki herhangi bir yapÄ±sal tipi kontrol etmek istersek, bunun iÃ§in _typeof_ kullanmak anlamsÄ±z olur, Ã§Ã¼nkÃ¼ her zaman â€œobjectâ€ Ã§Ä±ktÄ±sÄ±nÄ± alÄ±rÄ±z. Bu tarz bir durumda kesin bir sonuÃ§ alÄ±namasa da **instanceof** operatÃ¶rÃ¼nÃ¼ kullanmak mantÄ±klÄ± olabilir.

## 4.8-Number Veri TÃ¼rÃ¼ KullanÄ±mÄ±, Temel Aritmetik Ä°ÅŸlemler ve Ä°ÅŸlem Ã–nceliÄŸi ve ArttÄ±rma ve Azaltma Ä°ÅŸlemleri

**Number (SayÄ±) Veri TÃ¼rÃ¼**

JavaScript dili weakly-typed yani gÃ¼Ã§sÃ¼z tÃ¼rlÃ¼ bir dildir. DeÄŸiÅŸkenlerin ve parametrelerin tÃ¼rlerini bildirmek gerekmez. TÃ¼r kullanÄ±mdan dolaylÄ± olarak Ã§Ä±kartÄ±lÄ±r.  
Ã–rneÄŸin:

```
let x = 3;
```

ÅŸeklindeki tanÄ±mlamada deÄŸiÅŸkenin deÄŸeri tam sayÄ± (integer), aÅŸaÄŸÄ±daki Ã¶rnekte ise

```
let y = 3.14;
```

y deÄŸiÅŸkenin deÄŸer tÃ¼rÃ¼ kayan sayÄ± (float) tÃ¼rÃ¼ndedir. SayÄ±nÄ±n integer veya float olup olmadÄ±ÄŸÄ± nokta (.) olup olmamasÄ±ndan anlaÅŸÄ±lÄ±r.

**Aritmetik OperatÃ¶rler**

- Toplama: +
- Ã‡Ä±karma: -
- Ã‡arpma: \*
- Ãœs Alma: \*\*
- BÃ¶lme: /
- Mod Alma: %
- ArttÄ±rma: ++
- Eksiltme: --

**Toplama:** SayÄ±larÄ± toplama iÅŸlemini gerÃ§ekleÅŸtirir. Ä°ÅŸlem yÃ¶nÃ¼ soldan saÄŸadÄ±r.

```
    var result = 3+5;
    console.log(result);
    //8
```

**Ã‡Ä±karma:** Ä°ki sayÄ±yÄ± Ã§Ä±karma iÅŸlemini gerÃ§ekleÅŸtirir. Ä°ÅŸlem yÃ¶nÃ¼ soldan saÄŸadÄ±r.

```
    var result = 5-2;
    console.log(result);
    //3
```

**Ã‡arpma:** Ä°ki sayÄ±yÄ± Ã§arpma iÅŸlemini gerÃ§ekleÅŸtirir. Ä°ÅŸlem yÃ¶nÃ¼ soldan saÄŸadÄ±r.

```
    var result = 5*2;
    console.log(result);
    //10
```

**Ãœs Alma:** ECMAScript6 ile gelmiÅŸtir. Soldaki deÄŸerin, saÄŸdaki rakam veya sayÄ± baz alÄ±narak kendisiyle Ã§arpÄ±lmasÄ± ÅŸeklinde gerÃ§ekleÅŸir.

```
    var result = 5**2;
    console.log(result);
    //25
```

**BÃ¶lme:** Ä°ki sayÄ±yÄ± bÃ¶lme iÅŸlemini gerÃ§ekleÅŸtirir. Ä°ÅŸlem yÃ¶nÃ¼ soldan saÄŸadÄ±r.

```
    var result = 6/3;
    console.log(result);
    //2
```

**Mod Alma:** OperatÃ¶rÃ¼n solundaki deÄŸerin saÄŸdakine kalanÄ±nÄ± bulmak iÃ§in kullanÄ±lmaktadÄ±r. Ä°ÅŸlem yÃ¶nÃ¼ soldan saÄŸadÄ±r.

```
    var result = 6%3;
    console.log(result);
    //0
```

**Azaltma:** Bir sayÄ±yÄ± azaltmak iÃ§in kullanÄ±rÄ±z. DeÄŸeri 1 azaltÄ±r. For ve While dÃ¶ngÃ¼leri iÃ§inde sÄ±k sÄ±k kullanÄ±lÄ±r. ArttÄ±rma operatÃ¶rÃ¼nde anlatÄ±lan baÅŸa veya sonraya operatÃ¶r ekleme iÅŸlemi sonunda gerÃ§ekleÅŸen durum azaltma operatÃ¶rÃ¼ iÃ§inde geÃ§erlidir.

```
    let counter = 1;
    let a = --counter;
    alert(a); // 0
```

## 4.9-Boolean Veri TÃ¼rÃ¼

Program yazarken sadece iki ifade ile Ã§alÄ±ÅŸmak (evet yada hayÄ±r, _0_ yada _1_ gibi) programÄ±n anlaÅŸÄ±labilmesi ve yazÄ±m kolaylÄ±ÄŸÄ± aÃ§Ä±sÄ±ndan Ã§ok iÅŸimize yarar. Ä°ÅŸte bu veri tÃ¼rÃ¼nde ise iki ifade vardÄ±r. Bunlar _true_ ve _false_ tir.

```
Boolean(10>9); // true
```

```
Boolean(10>11); // false
```

```
const b1 = Boolean(100); // true
const b2 = Boolean(3.14); // true
const b3 = Boolean(-15); // true
const b4 = Boolean("Hello"); // true
const b5 = Boolean('false'); // true
const b6 = Boolean(1 + 7 + 3.14); // true
```

```
const c1 = Boolean(undefined); // false
const c2 = Boolean(null); // false
const c3 = Boolean(""); // false
const c4 = Boolean(false); // false
const c5 = Boolean(NaN); // false
const c6 = Boolean(0); // false
const c6 = Boolean(-0); // false
```

## 4.10-DeÄŸiÅŸken TÃ¼rÃ¼nÃ¼ Kontrol Etme

Ã‡alÄ±ÅŸtÄ±ÄŸÄ±mÄ±z veriler her zaman kodumuz iÃ§in uygun olmayabilir. Verilerin kontrolÃ¼nÃ¼ saÄŸlayÄ±p ona uygun kod yazabiliriz veya istediÄŸimiz tÃ¼re dÃ¶nÃ¼ÅŸtÃ¼rerek ilerleyebiliriz.

Bu kontrolleri yaparken sÄ±kÃ§a _typeof_ kullanÄ±lÄ±r.

```
console.log(typeof 42);
// beklenen output: "number"

console.log(typeof 'kodluyoruz');
//beklenen output: "string"

console.log(typeof true);
// beklenen output: "boolean"

console.log(typeof Variable);
// beklenen output: "undefined"
```

**Anahtar Notlar :**
Bir baÅŸka ÅŸekilde isInteger( ), isFinite( ) veya isNaN( ) kullanarak da kontrol saÄŸlayabiliriz.

```
//isInteger( ) yÃ¶ntemi, sayÄ±larÄ±n tam sayÄ± olup olmadÄ±ÄŸÄ±nÄ± belirler.
Number.isInteger(123) //true
Number.isInteger(-123) //true
Number.isInteger(0.5) //false
//isFinite () yÃ¶ntemi, bir deÄŸerin sonlu bir sayÄ± olup olmadÄ±ÄŸÄ±nÄ± belirler.
Number.isFinite(0) //true
Number.isFinite('123') //false
Number.isFinite('Hello') //false
Number.isFinite(-Infinity) //false
Number.isFinite(0 / 0) //false
// Number.isNaN () yÃ¶ntemi, bir deÄŸerin NaN (Not-A-Number) olup olmadÄ±ÄŸÄ±nÄ± belirler.

Number.isNaN(123) //false
Number.isNaN(0) //false
Number.isNaN('123') //false
Number.isNaN('Hello') //false
Number.isNaN('') //false
Number.isNaN(true) //false
Number.isNaN(undefined) //false
Number.isNaN('NaN') //false
Number.isNaN(NaN) //true
```

## 4.11-DeÄŸiÅŸken TÃ¼rÃ¼nÃ¼ DeÄŸiÅŸtirmek (Type Coercion)

Type Coercion; bir deÄŸiÅŸkenin tÃ¼rÃ¼nÃ¼, baÅŸka bir deÄŸiÅŸkene dÃ¶nÃ¼ÅŸtÃ¼rmeye yarayan yÃ¶ntemdir. Ä°ki tipi vardÄ±r. Bunlar explicit ve implicit dÃ¶nÃ¼ÅŸÃ¼mlerdir. Explicit iÃ§in metodlarla yapÄ±lan dÃ¶nÃ¼ÅŸÃ¼m denilebilir. Implicit ise operatÃ¶rler ile veya Javascript in kendi yaptÄ±ÄŸÄ± dÃ¶nÃ¼ÅŸÃ¼m diyebiliriz.

**Explicit Coercion**

```
String(123) // â€œ123â€
ParseInt(â€œ123â€) // 12
```

**Implicit Coercion**

```
If(3<5) // true
console.log(â€˜ â€™+123) // â€œ123â€
12/â€6â€ // 2
```

**String DÃ¶nÃ¼ÅŸÃ¼mÃ¼**

Bir deÄŸeri string e dÃ¶nÃ¼ÅŸtermek iÃ§in String() fonksiyonu kullanÄ±lÄ±r. Binary (kili) ifatede _+_ operatÃ¶rÃ¼ birstring ifadeye uygulandÄ±ÄŸÄ±nda ise implicit dÃ¶nÃ¼ÅŸÃ¼m tetiklenir.

```
String(123) // â€œ123â€ explicit
123 + ''    // â€œ123â€    implicit
```

**NOTLAR:**
Symbolâ€™de durum biraz farklÄ±dÄ±r, Ã§Ã¼nkÃ¼ dÃ¶nÃ¼ÅŸÃ¼m sadece explicit bir ÅŸekilde yapÄ±labilir, implicit bir ÅŸekilde yapÄ±lamaz.

```
String(Symbol('my symbol')) // 'Symbol(my symbol)'
'' + Symbol('my symbol') // TypeError is thrown
```

**Boolean DÃ¶nÃ¼ÅŸÃ¼mÃ¼**  
Bir deÄŸeri explicit boolean a dÃ¶nÃ¼ÅŸtÃ¼rmek iÃ§in Boolean() metodu kullanÄ±lÄ±r.  
Ä°mplicit coercion dÃ¶nÃ¼ÅŸÃ¼m ise mantÄ±ksal operatÃ¶rlerin kullanÄ±ldÄ±ÄŸÄ±nda tetiklenir.

```
Boolean(2) // explicit
var a=!!2 //explicit
if (2) { ... } // implicit due to logical context
!!2 // implicit due to logical operator
2 || 'hello' // implicit due to logical operator
```

**Ã–rekler**

```
Boolean('') // false
Boolean(0) // false
Boolean(-0) // false
Boolean(NaN) // false
Boolean(null) // false
Boolean(undefined) // false
Boolean(false) // false

Boolean({}) // true
Boolean([]) // true
Boolean(Symbol()) // true
!!Symbol() // true
Boolean(function() {}) // true
```

**Nesneler (Objects) iÃ§in Type Coercion**
Javascript te nesneler referans tipler olduÄŸundan Ã¼zerlerinde deÄŸiÅŸiklik yapmak biraz zordur. DeÄŸiÅŸiklik yapabilmemiz iÃ§in elimizde primitif tip olmasÄ± gerekir. Yani referans tipler primitif tiplere zorlanÄ±r. Primitif olmayan herhangi bir deÄŸer yada obje (object veya array) dolu yada boÅŸ farketmez true deÄŸere dÃ¶necektir.

```
console.log(Boolean({})) // true
console.log(Boolean([])) // true
console.log(Boolean([1,2,3])) // true
console.log(Boolean({13:234})) //true
```

## 4.12-Template Literals KullanÄ±mÄ±

Template literals (Ã¶neki adÄ± template Strings), kod okunabilirliÄŸi ve yazÄ±m kolaylÄ±ÄŸÄ± saÄŸlayan ES6 ile gelmiÅŸ bir string yazma ÅŸeklidir.

**SaÄŸladÄ±ÄŸÄ± faydalar**

- Ã‡ok satÄ±rlÄ± dize yazÄ±mÄ±

```
//Eski kullanÄ±m:
let eskiString = "En sevdiÄŸim yemekler:\nÄ°skender\nMantÄ±"

//Yeni kullanÄ±m:
let yeniString = `En sevdiÄŸim yemekler:
Ä°skender
MantÄ±`
```

- Ä°nterpolasyon : metin iÃ§erisinde deÄŸiÅŸken kullanmak anlamÄ±na gelir.

```
let ad= `Ziya`;
let soyad= `Ã‡AYLAN`;

//Eski kullanÄ±m
console.log("Benim adÄ±m "+ad+" "+ soyad);

//Yeni kullanÄ±m
console.log(`Benim adÄ±m ${ad} ${soyad}`);
```

- Html ÅablonlarÄ± : Ã‡ok satÄ±rlÄ± dizeleri kolaylÄ±kla kullanmak ve dizelerimize iÃ§erik eklemek iÃ§in de Template Literalâ€™den faydalanabiliriz.

```
//DeÄŸiÅŸkenlerimizi tanÄ±mlayalÄ±m
const ad =`Ziya`
const soyad =`Ã‡AYLAN`
const gozRengi =`Kahverengi`
const yas =39


const kisi = `
<p>${ad}</>
<p>${soyad}</>
<p>${gozRengi}</>
<p>${yas}</>
`;

document.body.innerHTML = kisi;

//Bu kullanÄ±m daha az karmaÅŸÄ±k ve okunabilir.
```

**KÄ±saca FaydalarÄ±nÄ± sÄ±ralarsak**

- Kod okunabilirliÄŸini kolaylaÅŸtÄ±rÄ±r
- String ifadeler iÃ§erisinde deÄŸiÅŸken yazma kolaylÄ±ÄŸÄ± saÄŸlar,
- Åablon etiketlerini daha karmaÅŸÄ±k hale getirir.

[Linkteki Ã¶rneÄŸi inceleyiniz.](./Javascript-Dersleri/template-literal-example/template-literal.js). Ã–rnekte template literal kullanÄ±larak web sayfasÄ±nda kitaplar listelenmiÅŸtir.

## 4.13-String Veri TÃ¼rÃ¼ Ä°ÅŸlemleri

**String nedir ?**

Javascript e metinlerin tÃ¼mÃ¼ _string_ veri tipinde tutulur.

**Length Ã–zelliÄŸi**

String ifadenin uzunluÄŸunu bize verir. AÅŸaÄŸÄ±daki Ã¶rneÄŸi inceleyiniz.

```
const str = "javascript";
// bu ifadenin sonucu konsol ekranÄ±nda 10 olarak gÃ¶rÃ¼ntÃ¼lenecektir.
console.log(str.length);
```

**indexOf Ã–zelliÄŸi**

Metin iÃ§erisinde arama yapmak istediÄŸimizde bize aradÄ±ÄŸÄ±mÄ±z deÄŸerin index numarasÄ±nÄ± verir.

```
const str = "Ziya Ã§aylan";
// 'ya' nÄ±n baÅŸladÄ±ÄŸÄ± index numarasÄ±nÄ± geri dÃ¶ner yani 2
console.log(str.indexOf("ya"));
```

**lastIndexOf Ã–zelliÄŸi**

indexOf ile aynÄ± Ã§alÄ±ÅŸÄ±r ancak arasÄ±ndaki fark; metin iÃ§erisinde arama yapmak istediÄŸimizde aradÄ±ÄŸÄ±mÄ±z deÄŸerin en son karÅŸÄ±laÅŸtÄ±ÄŸÄ± index numarasÄ±nÄ± geri dÃ¶ner. AÅŸaÄŸÄ±daki Ã¶rnekte olduÄŸu gibi

```
const str = "Ziya Ã§aylan";
// 'a' nÄ±n en son gÃ¶rÃ¼ldÃ¼ÄŸÃ¼ index numarasÄ±nÄ± geri dÃ¶ner yani 9
console.log(str.indexOf("a"));
```

**Search - Metin Ä°Ã§erisinde Arama Yapma**

indexOf ile aynÄ± ÅŸekilde Ã§alÄ±ÅŸÄ±r ve _"Regular Expressions"_ iÅŸlemlerinde Ã§ok kullanÄ±lmaktadÄ±r.

```
const str = "Ziya Ã§aylan";
// 'ya' index numarasÄ±nÄ± geri dÃ¶ner yani 2
console.log(
  `Search ile "ya" yÄ± aradÄ±ÄŸÄ±mÄ±zda geri dÃ¶nen deÄŸer ${str.search("ya")}`  // konsolda : Search ile "ya" yÄ± aradÄ±ÄŸÄ±mÄ±zda geri dÃ¶nen deÄŸer 2
);
```

**Slice - Metinden ParÃ§a Alma**

- Bu metod ile metinden bir parÃ§a almak istediÄŸimizde almak istediÄŸimiz yerin index numarasÄ±nÄ± vererek alabiliriz.

```
const str = "Ziya Ã§aylan";

console.log(str.slice(2, 4)); // 2. index numarasÄ±ndan baÅŸlar ve 4. index numarasÄ±na kadar alÄ±r ancak 4. index dahil deÄŸildir.
```

- slice metoduna tek parametre verdiÄŸimizde ise; verdiÄŸimiz parametreden baÅŸlar ve metinin sununa kadar alÄ±r

```
const str = "Ziya Ã§aylan";

console.log(str.slice(2)); // 2. index numarasÄ±ndan baÅŸlar ve sona kadar alÄ±r Konsolda : ya Ã§aylan
```

- index numarasÄ± hiÃ§ yazmaz isek metini komple alÄ±r.

**Replace - Metodu (Metin bulma ve deÄŸiÅŸtirme)**

AradÄ±ÄŸÄ±mz metini bulmamÄ±zÄ± ve istediÄŸimiz metin ile deÄŸiÅŸtirmemizi saÄŸlar.

```
const str = "Ziya Ã§aylan";

console.log(str.replace("Ã§aylan", "Ã‡AYLAN")); // ""Ã§aylan metinini bulur ver onun yerine "Ã‡AYLAN" yazar
```

**toUpperCase ve toLowerCase**

- toUpperCase ile metin bÃ¼yÃ¼k harfe Ã§evrilir.
- toLowerCase ile de metin tamamÄ± kÃ¼Ã§Ã¼k harfe Ã§evrilir.

```
const str = "Ziya Ã§aylan";

console.log(str.toUpperCase()); // ZIYA Ã‡AYLAN
console.log(str.toLocaleLowerCase()); // ziya Ã§aylan
```

**Concat - Metin BirleÅŸtirme**

- Elimizdeki iki string tÃ¼rÃ¼nden veriyi birleÅŸtirmemize olanak saÄŸlar

```
const myName = "ziya";
const surname = "Ã§aylan";

console.log(myName.concat(" ", surname)); //myName den sonra belirttiÄŸimiz gibi " " (bir boÅŸluk bÄ±rakÄ±r ve surname i ekler) konsolda : ziya Ã§aylan
```

**charAt- Ä°ndex NumarasÄ±na GÃ¶re Karakter Bulmak**

- BelirttiÄŸimiz index numarasÄ±ndaki karakteri geri dÃ¶ndÃ¼rÃ¼r.

```
const str = "Ziya Ã§aylan";

console.log(str.charAt(2)); // y
console.log(str.charAt(3)); // a
```

**charCodeAt â€“ Ä°ndex NumarasÄ±na GÃ¶re Karakterin Unicode DeÄŸerini Bulma**

- BelirttiÄŸimiz index numarasÄ±ndaki karakterin Unicode deÄŸerini geri dÃ¶ndÃ¼rÃ¼r.

```
const str = "Ziya Ã§aylan";

console.log(str.charCodeAt(2)); // 121
```

**Split â€“ Metni Diziye Ã‡evirme**

- splite metodu ile metin diziye Ã§evrilebilir.
- KullanÄ±lan parametre ile de metinin nasÄ±l parÃ§alanacaÄŸÄ± belirlenir.

```
const str = "Ziya Ã§aylan";

const isimler = str.split(" ");
console.log(isimler); // [ 'Ziya', 'Ã§aylan' ]

const metin = "ziya-ali-veli-hasan-hÃ¼seyin-mehmet-mahmut-canan-caner-eda-seda";
console.log(metin.split("-")); // ['ziya','ali','veli','hasan','hÃ¼seyin','mehmet','mahmut','canan','caner','eda','seda']
```

[Linkteki string Ã¶rneklerini inceleyiniz.](./Javascript-Dersleri/string-ozellikleri/string.js).

**BazÄ± Ã–rnekler**

```
// istenilen karakterden sonrasÄ±nÄ± alma
// Ã–rnek --> ziyacaylan@gmail.com
// '@' iÅŸaretinden sonraki karakterleri alma

const email = "ziyacaylan@gmail.com";

const domain = email.slice(email.search("@") + 1);
console.log(domain);  // gmail.com

const userName = email.slice(0, email.search("@"));
console.log(userName);  // ziyacaylan
```

## 4.14-Document Object Model (DOM) Nedir ?

- 3C (World Wide Web Consortium) a gÃ¶re DOM programlarÄ±n ve komut dosyalarÄ±nÄ±n bir belge iÃ§eriÄŸine yapÄ±sÄ±na ve stiline dinamik olarak eriÅŸmesine ve gÃ¼ncellemesine izin veren bir platform ve dilden baÄŸÄ±msÄ±z bir arayÃ¼zdÃ¼r.
- HTML yapÄ±sÄ±nÄ± daha Ã¶nce incelemiÅŸtik. TarayÄ±cÄ±nÄ±n belgeyi temsil etmek iÃ§in kullandÄ±ÄŸÄ± veri yapÄ±sÄ± bu ÅŸekli izler.Her kutu iÃ§in, hangi HTML etiketini temsil ettiÄŸi ve hangi kutularÄ± ve metni iÃ§erdiÄŸi gibi ÅŸeyleri bulmak iÃ§in etkileÅŸime girebileceÄŸimiz bir nesne vardÄ±r. Bu temsil, **Document Object Model** veya kÄ±saca **DOM** olarak adlandÄ±rÄ±lÄ±r.
- DOM bir aÄŸaÃ§ dizini gibi bÃ¼tÃ¼n dokÃ¼manlarÄ± birbirine baÄŸlar.  
  ![DOM](./Javascript-Dersleri/assets/dom.jpg)

  [Linkteki Ã¶rnekleri inceleyiniz.](./Javascript-Dersleri/dom/index.html)

**DOM iÃ§erisinden Etiket ve ID ile Ã–ÄŸe SeÃ§imi**

- document objesinin getElemntById() metodu kullanÄ±larak sayfadaki html elementlerinin ID leri referans alÄ±narak seÃ§im iÅŸlemi yapÄ±labilir.
- ID'ler bÃ¼yÃ¼k-kÃ¼Ã§Ã¼k harf duyarlÄ±dÄ±r. Bu sayede HTML document iÃ§inde biriciklik gÃ¶sterir ve her zaman geriye bir eleman dÃ¶ndÃ¼rÃ¼r. Bir eÅŸleÅŸme bulamazsa da geriye _null_ dÃ¶nÃ¼ÅŸÃ¼nÃ¼ yapar.

```
document.getElementById('#root'); // null
document.getElementById('root'); // <section id=â€‹"root">â€‹â€¦â€‹</section>â€‹
```

**Get Elements By Tag Name**

- ElemanlarÄ± etiket isimlerine gÃ¶re seÃ§mek iÃ§in document objesinin _getElemntByTagName()_ metodu kullanÄ±lÄ±r.
- Genelde birden Ã§ok elemana ulaÅŸmak iÃ§in kullanÄ±lÄ±r.
- Girdi olarak bir _html elementi_ alÄ±r ve geriye bir _HTMLCollection_ dÃ¶ndÃ¼rÃ¼r.

**Get Elements By Name**

- ElemanlarÄ± isimleri gÃ¶re getirmek iÃ§in document objesinin _getElementByName()_ metodu kullanÄ±lÄ±r.
- ElemanlarÄ± name deÄŸerlerine gÃ¶re bir _NodeList objesi_ dÃ¶ndÃ¼rÃ¼r.

```
<input type="text" name="e-posta">
<input type="tel" name="telefon">
<input type="date" name="tarih">
```

telefon adÄ±nÄ± taÅŸÄ±yan elemanlarÄ± getirelim

```
const tel = document.getElementsByName('telefon');
console.log(tel) // NodeListÂ [input]
```

**Get Elements By Class Name**

- DOM da istediÄŸimiz class name e sahip olan elementleri seÃ§mek iÃ§in _getElemntByClassName()_ metodu kullanÄ±lÄ±r.
- Bu metodda bize HTMLCollection dÃ¶ndÃ¼rÃ¼r.
- KullanÄ±rken class name baÅŸÄ±na **nokta** _"."_ koymalÄ±yÄ±z.

```
    <div class="baykuÅŸ kusu">ğŸ¦‰</div>
    <div class="guvercin kusu">ğŸ¦</div>
    <div class="kartal kusu">ğŸ¦…</div>
    <div class="kedi">ğŸ±</div>
```

```
    //Get Elements By Class Name
    const kuslar = document.getElementsByClassName("kusu");
    console.log(kuslar); // HTMLCollection(3)Â [div.baykuÅŸ.kusu, div.guvercin.kusu, div.kartal.kusu]
```

**Query Selector**

- QuerySelector () yÃ¶ntemi, css seÃ§icilere baÄŸlÄ± olarak DOM da html elemanlarÄ±nÄ± seÃ§memize olanak saÄŸlayan iki modern javascript yÃ¶nteminden biridir.
- Bu yÃ¶ntem ile elementlerin hem class larÄ±nÄ± hemde id lerini kullanabiliriz.
- Bunu yaparken classlarÄ±n Ã¶nÃ¼ne "." id lerin Ã¶nÃ¼ne ise "#" kullanmamÄ±z gerekir.
- Sayfada ilk eÅŸleÅŸen eleman Ä± geriye dÃ¶ndÃ¼rÃ¼r.
- Belirtilen eleman ile eÅŸleÅŸmez ise geriye _null_ dÃ¶necektir.

**Query Selector All**

- querySelectorAll() metodu, QuerySelector () metodu ile aynÄ± mantÄ±k ile Ã§alÄ±ÅŸÄ±r tek farkÄ± eÅŸleÅŸen ilk elamanÄ± dÃ¶ndÃ¼rmek yerine eÅŸleÅŸen tÃ¼m elemanlarÄ± bir NodeList objesi olarak dÃ¶ndÃ¼rmesidir.

**Prompt ile KullanÄ±cÄ±dan bilgi alma**

- javascript te kullanÄ±cÄ±dan bilgi almak iÃ§in kullanÄ±lÄ±r.
- alÄ±nan bilgi bir deÄŸiÅŸkene atanabilir; sÃ¶zdizimi ÅŸu ÅŸekilde olacaktÄ±r: const _kelime = prompt("LÃ¼tfen bir kelime yazÄ±nÄ±z :");_

```
<div id="isim">Benim AdÄ±m :</div>
```

yukarÄ±daki html koduna javascript dosyamÄ±zdan ulaÅŸarak bir isim girelim

```
/*prompt () kullanÄ±mÄ± */
let myName = prompt("LÃ¼tfen adÄ±nÄ±zÄ± yazÄ±nÄ±z :");
let isim = document.querySelector("#isim");

isim.innerHTML = `${isim.innerHTML} <strong style = "color : blue;"
>${myName}</strong>`;
```

Prompt mantÄ±ÄŸÄ± ÅŸu ÅŸekildedir.

- KullanÄ±cÄ± **Tamam** dÃ¼ÄŸmesine tÄ±kladÄ±ÄŸÄ±nda geriye girilen deÄŸer dÃ¶ndÃ¼rÃ¼lÃ¼r.
- Herhangi bir metin girmeden **Tamam** dÃ¼ÄŸmesine tÄ±klanÄ±r ise geriye boÅŸ bir dize dÃ¶ner.
- KullanÄ±cÄ± **Ä°ptal** dÃ¼ÄŸmesine tÄ±klar ise iÅŸlev boÅŸ dÃ¶ndÃ¼rÃ¼r.

**DOM'a CSS Class Bilgisi Eklemek veya Ã‡Ä±karmak**

- Javascript te css sÄ±nÄ±flarÄ±na manipÃ¼le etmenin en iy i yollarÄ±ndan birisi **classList** kullanmaktÄ±r.
- **classList** bir Ã¶ÄŸenin sÄ±nÄ±f isimlerini **DOMTokenList** olarak dÃ¶ndÃ¼rÃ¼r.
- **classList** Ã¶zelliÄŸi bÃ¼tÃ¼n modern browserlarda Ã§alÄ±ÅŸmaktadÄ±r.

```
<head>
<title>Dome Example</title>
    <style>
      .text-primary {
        color: blue;
      }
      .btn {
        display: inline-block;
        border: none;
        width: auto;
        height: 2rem;
        border-radius: 0.4rem;
      }
      .btn-primary {
        background-color: blue;
      }
      .text-white {
        color: white;
      }
      .text-secondary {
        color: darkviolet;
      }
    </style>
  </head>
  <body>
    <h1 id="baslik">Frontend Dersleri / Javascript / DOM</h1>
    <button id="btn" class="btn">Benim Butonum</button>

    <script src="./class-elkeme.js"></script>
  </body>
```

YukarÄ±daki html sayfasÄ±na ulaÅŸarak class isimlere ulaÅŸÄ±p ekleme ve class silme iÅŸlemlerini deneyelim.

```
/*Listeye ulaÅŸmak ve eleman eklemek veya elemanÄ± deÄŸiÅŸtirmek */

let lastItem = document.querySelector("ul#list>li:last-child");

//console.log(lastItem);

lastItem.innerHTML = "Son Ã¶ÄŸeye ulaÅŸÄ±ldÄ± ve deÄŸiÅŸtirildi";

// ilk Ã¶ÄŸeye ulaÅŸmak
let firstItem = document.querySelector("ul#list>li:first-child");

firstItem.innerHTML = "Ä°lk Ã¶ÄŸeye ulaÅŸÄ±ldÄ± ve deÄŸiÅŸtirildi.";

// listeye yeni bir Ã¶ÄŸe eklemek

let ulList = document.querySelector("ul#list");

let newItem = document.createElement("li");

newItem.innerHTML = "Yeni eleman eklendi";

ulList.append(newItem); // son eleman olarak ekleme yapar

ulList.prepend(newItem); // ilk eleman olarak ekler
```

**Properties**

- **add() :** HTML Ã¶ÄŸerise bir veya daha fazla class eklemek iÃ§in kullanÄ±lÄ±r.
- **remove() :** HTML Ã¶ÄŸesinden bir veya daha fazla class silmek iÃ§in kullanÄ±lÄ±r.
- **item() :** HTML de class'Ä± verilen index sÄ±rasÄ±na gÃ¶re dÃ¶ndÃ¼rÃ¼r. EÄŸer index, class length'inden (sayÄ±sÄ±ndan) daha bÃ¼yÃ¼k veya length'ine eÅŸit olursa undefined dÃ¶ner.
- **contains() :** HTML Ã¶ÄŸesinin verilen class ismini iÃ§eriyorsa _true_ iÃ§ermiyorsa _false_ dÃ¶ner. Bu sayede iÅŸlem yaptÄ±rmadan Ã¶nce kontrol saÄŸlamÄ±ÅŸ oluruz.
- **toggle() :** _classList.add()_ ve _classList.remove()_ yÃ¶ntemini aynÄ± anda Ã§aÄŸÄ±rmak yerine _classList.toggle()_ yÃ¶ntemini kullanÄ±labilir.
  **Anahtar NOT :** Bu metodu kullanmadan Ã¶nce contains() metodu ile sÄ±nÄ±fÄ±n var olup olmadÄ±ÄŸÄ±nÄ± manuel olarak kontrol etmek gerekir.
- **replace() :** Bir css classÄ±nÄ± baÅŸka bir sÄ±nÄ±f ile deÄŸiÅŸtirmek iÃ§in kullanÄ±lÄ±r.
- **length() :** Bir Ã¶ÄŸenin sahip olduÄŸu sÄ±nÄ±f sayÄ±sÄ±nÄ± bulmak iÃ§in kullanÄ±lÄ±r.

## 4.15-KarÅŸÄ±laÅŸtÄ±rma OperatÃ¶rleri ve MantÄ±ksal OperatÃ¶rler

### KarÅŸÄ±laÅŸtÄ±rma OperatÃ¶rleri

- **== EÅŸitse** OperatÃ¶rÃ¼ :

```
const a = 10;
const b = "10";
console.log(a == b); // true
```

- **=== Hem deÄŸeri hem de tÃ¼rÃ¼ eÅŸit ise** OperatÃ¶ri

```
/*=== Hem deÄŸeri hem de tÃ¼rÃ¼ eÅŸit ise */
const a = 10;
const b = "10";

console.log(a === b); // false -> DeÄŸeri eÅŸit fakat tÃ¼rÃ¼ farklÄ± olduÄŸundan false
```

- **!= EÅŸit deÄŸilse** OperatÃ¶rÃ¼

```
const a = 10;
const b = "10";

/*!= EÅŸit deÄŸilse */

console.log(a != b); // deÄŸerleri eÅŸit fakat deÄŸili false

console.log(a !== b); // deÄŸeri eÅŸit fakat tÃ¼rÃ¼ farklÄ± ancak deÄŸili true
```

- **< KÃ¼Ã§Ã¼kse** ve **<= KÃ¼Ã§Ã¼k veya eÅŸitse** OperatÃ¶rleri

```
const a = 10;
const b = 10;

/*< KÃ¼Ã§Ã¼kse */
console.log(a < b); // false

/*<= KÃ¼Ã§Ã¼k veya eÅŸitse */
console.log(a <= b); // true
```

- **> BÃ¼yÃ¼kse** ve **>= BÃ¼yÃ¼k veya eÅŸitse** OperatÃ¶rleri

```
const a = 10;
const b = 10;

/* > BÃ¼yÃ¼kse ve >= BÃ¼yÃ¼k veya eÅŸitse */

console.log(a > b); // false

console.log(a >= b); // true
```

### MantÄ±ksal OperatÃ¶rler

MantÄ±ksal operatÃ¶rler ile birden fazla koÅŸula gÃ¶re karÅŸÄ±laÅŸtÄ±ma yapabiliriz. KarÅŸÄ±laÅŸtÄ±rma sonucunda _true_ yada _false_ deÄŸeri dÃ¶ner

- **&& ve**

```
const a = 10;
const b = 10;
constc = 20;

//&& ve
console.log(`&& ve : ${a === b && a < c}`); // true
```

- **|| veya**

```
const a = 10;
const b = 10;
constc = 20;

// || veya
console.log(`|| veya : ${a === b || a > c}`); // true
```

- **! deÄŸil**

```
const a = 10;
const b = 10;
constc = 20;

// "! deÄŸil"
console.log(`! deÄŸili : ${!(a === b || a > c)}`); // false
```

## 4.16-if / else (koÅŸul yapÄ±sÄ±) KullanÄ±mÄ±

- If else yapÄ±sÄ± iÃ§erisinde koÅŸulun saÄŸlandÄ±ÄŸÄ± kodlar if iÃ§erisinde yer alÄ±rken, koÅŸulun saÄŸlanmadÄ±ÄŸÄ± kodlar ise else iÃ§erisinde yer alÄ±r.
- EÄŸer ilk koÅŸul yanlÄ±ÅŸsa baÅŸka bir koÅŸul belirtmek amacÄ±yla else if kullanÄ±lÄ±r.

```
if(kosul) {
    // Bu kod satÄ±rÄ± Ã§alÄ±ÅŸacaktÄ±r.
}

else {
    // Bu kod satÄ±rÄ± Ã§alÄ±ÅŸÄ±r.
}
```

**Ã‡ALIÅMA SORUSU**

- Bilgisayar tarafÄ±ndan 1-10 arasÄ± belirlenen bir sayÄ±yÄ±, kullanÄ±cÄ±dan klavye ile girilen bir sayÄ± ile hatmin edilmeye Ã§alÄ±ÅŸÄ±lan yapÄ±yÄ± kurgulayarak yazÄ±nÄ±z.
- web sayfasÄ± Ã¼zerinde girilen sayÄ±, tahmin edilen sayÄ± ve sonuca gÃ¶re doÄŸru yada yanlÄ±ÅŸ olduÄŸunu belirtiniz.

**_CEVAP_**  
 [Linkten Ã§alÄ±ÅŸma dosyasÄ±na ulaÅŸarak inceleyiniz.](./Javascript-Dersleri/Karar-Yapilari-ve-Kosullar/karsilastirma-operatorleri-ve-mantiksal-operatorler/karsilastirma-operatorleri.js)  
[index.html sayfa linki](./Javascript-Dersleri/Karar-Yapilari-ve-Kosullar/index.html)

## 4.17-switch (Ã§oklu koÅŸul yapÄ±sÄ±) KullanÄ±mÄ±

Javascriptte if-else yapÄ±sÄ±nda koÅŸul sayÄ±sÄ±nÄ±n arttÄ±ÄŸÄ± durumlarda kod okunurluÄŸunu arrÄ±tmak ve daha performanslÄ± sayÄ±labilecek bir yapÄ± olan _switch_ kullanÄ±lÄ±r.

**Syntax**

```
switch(ifade) {
  case a:
    // kod bloÄŸu
    break;
  case b:
    // kod bloÄŸu
    break;
  default:
    // kod bloÄŸu
}
```

**Ã–RNEK**

```
let hava = "Gunesli";
switch(hava) {
  case "Yagmurlu":
      console.log("Semsiyeni yanina almayi unutma");
      break;
  case "Gunesli":
      console.log("Hafif giyin");
  case "Bulutlu":
      console.log("Disari cik");
      break;
  case "KarlÄ±":
      console.log("Kalin giyin");
      break;
  case "Firtinali":
      console.log("Bir sÃ¼re disari cikma");
      break;
  default:
      console.log("Bilinmeyen hava durumu:" , hava);
}
```

AÅŸaÄŸÄ±da switch akÄ±ÅŸ diyagramÄ± Ã¶rnek olarak verilmiÅŸtir ve nasÄ±l Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± inceleyebilirsiniz...  
![switch-case](./Javascript-Dersleri/assets/switch-case.jpg)

## 4.18- Ternary OperatÃ¶rÃ¼

- **Ternary Operator** 3 adet parametre alan tekJavascript operatÃ¶rÃ¼dÃ¼r
- _If_ kullanarak kontrol etmek istediÄŸimiz koÅŸullarda _ternary operator_ kullanarak satÄ±r sayÄ±sÄ± olarak avantaj saÄŸlayabiliriz.

**Ternary operatÃ¶rÃ¼nÃ¼n aldÄ±ÄŸÄ± 3 parametre ÅŸu ÅŸekildedir:**

- Ä°lk Ã¶nce bir condition belirtiriz ve sonra _?_ koyarÄ±z
- Sonra yazdÄ±ÄŸÄ±mÄ±z condition doÄŸru ise ne yapmak istediÄŸimizi yazarÄ±z ve sonuna _:_ koyarÄ±z
- Ve son olarakda condition false ise ne yapmak istediÄŸimizi yazarÄ±z.

**Anahtar NOT:**
Ternary operatÃ¶rleri aynÄ± zamanda birbiri ardÄ±na zincirleyerek (chaining) kullanabiliriz. Bu sayede farklÄ± olasÄ±lÄ±klarÄ± da katarak daha detaylÄ± senaryolarÄ± kontrol edebiliriz.

```
const para = 40;
const satinAlma =
    (para < 17) ? "SatÄ±n alamazsÄ±n..":
    (para > 30) ? "SatÄ±n alabilirsin..":
    "Para miktarÄ±nÄ± girmen gerekmektedir..";

console.log(satinAlma) // "SatÄ±n alabilirsin.."
```

## 4.19- Fonksiyon Nedir? Neden KullanÄ±rÄ±z?

Fonksiyon bir iÅŸlevi yerine getirmek iÃ§in tasarlanmÄ±ÅŸ kod bloklarÄ±dÄ±r. KodlaerÄ±mÄ±za iÅŸlevsellik katmak iÃ§in sÄ±k sÄ±k kullanÄ±rÄ±z.

**Fonksiyon AdlandÄ±rma Fonksiyon Bildirimi(Function Declaration)**

- ilk olarak _function_ ibaresi yazÄ±lÄ±r ve sonra fonksiyonun ismi yazÄ±lÄ±r.
- fonksiyon isimleri belirlenirken bir eylem bildiren isimler kullanÄ±lmalÄ±dÄ±r. Fonksiyon isimleri bazÄ± Ã¶n ekler alabilirler.
- Ã–rneÄŸin bir deÄŸer almak istediÄŸimizde **_get_**, bir deÄŸeri deÄŸiÅŸtirmek istediÄŸimizde **_set_** yada duÄŸru yada yanlÄ±ÅŸ (true-false) gibi bir sonuÃ§ almak istediÄŸimizde ise **_is_** Ã¶n eki eklenebilir.
- Bununla birlikte ÅŸunu da unutmamalÄ±yÄ±z istendiÄŸinde adÄ± olmayan anonim bir fonksiyon da kullanÄ±labilir. AÅŸaÄŸÄ±da bu fonksiyon tÃ¼rÃ¼nden bahsediliyor

- fonksiyon isminden sonra parantezler iÃ§erisinde parametreler verilir. Parametre girmek zorunlu olmadÄ±ÄŸÄ± gibi fazla parametre girmek de kodun okunurluÄŸunu bozabilir.
- parametre alan bu fonksiyonlarÄ± kullandÄ±ÄŸÄ±mÄ±zda parametrelere kendmiz deÄŸer atarÄ±z. Atanan bu deÄŸerlere **_argÃ¼man_** adÄ± verilir.
- fonksiyon isimleri kÃ¼Ã§Ã¼k harf ile baÅŸlanmalÄ± ve iki kelimenin yada daha fazla kelimenin birleÅŸimi ile sonradan gelen kelimeler arasÄ±nda boÅŸluk v.b. kullanÄ±lmamalÄ± ve ilk kelimeden sonraki kelimenin baÅŸ harfleri bÃ¼yÃ¼k yazÄ±lmalÄ±dÄ±r.
- fonksiyon ismi ve var ise parantezler arasÄ±nda parametreler verildikten sonra parantez kapatÄ±lÄ±r ve sÃ¼slÃ¼ parantezler aÃ§Ä±larak javascript kodlarÄ± eklenir. Bu sÃ¼slÃ¼ parantezler arasÄ±ndaki kÄ±sÄ±m _fonksiyonun gÃ¶vdesi_ denir.

```
function printHello(name) {
  console.log("Merhaba " + name);
}

printHello("Ziya");  // Merhaba Ziya
```

**Anahtar NOTLAR:**

- Fonksiyonun tanÄ±mÄ± bir **_statement_** dÄ±r. (geriye deÄŸer dÃ¶ndÃ¼rmez.)
- Ancak yazÄ±lan fonksiyon Ã§alÄ±ÅŸtÄ±rÄ±lÄ±r ise **return** kullanmasa bile geriye deÄŸer dÃ¶ndÃ¼rÃ¼r Buna **_expression_** denir

**_Anonymous Functions_**
Bazen fonksiyonlara isim vermeden de kullanÄ±lÄ±r. Bunlar anonymous fonksiyonlardÄ±r. anonymous fonksiyonlarÄ±n bir isimi yoktur ve bir deÄŸiÅŸkene atanarak kullanÄ±lÄ±rlar.
DeÄŸiÅŸken adÄ± kullanÄ±larak Ã§aÄŸrÄ±ldÄ±klarÄ± iÃ§in birden Ã§ok anonim fonksiyonu aynÄ± dizide kullanabilirsiniz.DahasÄ± bir deÄŸiÅŸkene atandÄ±klarÄ±ndan bu deÄŸiÅŸkeni baÅŸka bir fonksiyonun parametresine koyarak **_callback_** (geri arama) yapabilirsiniz.

```
function addition(sayi1,sayi2){  //function name and parameters
        console.log(sayi1+sayi2);     //body
}
```

```
const add = function (sayi1,sayi2){  //Anonim bir fonksiyon oluÅŸturduktan sonra bu
                                   //fonsksiyonu bir deÄŸiÅŸkene atadÄ±k
        console.log(sayi1+sayi2);
}
```

**DeÄŸer DÃ¶ndÃ¼ren Fonksiyonlar**

- Bazen fonksiyondan geriye deÄŸer dÃ¶ndÃ¼rÃ¼p bunu da baÅŸka iÅŸlemler iÃ§in kullanÄ±r yada baÅŸka bir fonksiyona parametre olarak verebiliriz.
- BÃ¶yle durumlarda **_return_** ifadesi kullanÄ±larak geriye deÄŸer dÃ¶ndÃ¼rÃ¼lÃ¼r.

```
function sum(number1,number2){
return (number1+number2);
}
const add = sum(5,10); // 15
```

**Fonksiyon KapsamÄ±**

- Javascriptte fonksiyon iÃ§erisinde tanÄ±mlanmÄ±ÅŸ olan deÄŸiÅŸkene dÄ±ÅŸarÄ±daki herhangi bir yerden eriÅŸilemez.
- TanÄ±mlanan deÄŸiÅŸken **_fonksiyon kapsamÄ±ndadÄ±r._**
- Fonksiyon iÃ§erisinde kullanÄ±lan deÄŸiÅŸken **_lokal deÄŸiÅŸken_** adÄ± verilir.
- Ancak fonksiyon tanÄ±mlandÄ±ÄŸÄ± anda, tanÄ±mlandÄ±ÄŸÄ± kapsamdaki **_global deÄŸiÅŸkenlere_** eriÅŸebilir.

```
const number1 = 3;
const number2 = 5;

function sum(sayi1,sayi2){
    let sayi3 = 0; /sayi3 adÄ±nda lokal bir deÄŸiÅŸken tanÄ±mlÄ±yoruz
    return sayi1+sayi2+sayi3;  //Fonksiyon iÃ§inde global ve local deÄŸiÅŸkenleri kullanÄ±yoruz
}

function multiSum (){
    return number1 + number2 + sayi3; // error
}

```

**Callback Fonksiyonlar ve Asenkron Ã‡alÄ±ÅŸma**

- javascriptte kodumuz yukarÄ±dan aÅŸaÄŸÄ±ya doÄŸru okunur ve bir Ã¶nceki satÄ±r bitmeden bir sonrakine geÃ§ilmez. Buna **_senkron Ã§alÄ±ÅŸma_** denir.
- asenkron Ã§alÄ±ÅŸmada ise fonksiyonlarÄ±n birbirlerini beklemelerine gerek yoktur.
- javascript asenkron yapÄ±daki bir programlama dilidir.
  AÅŸaÄŸÄ±daki Ã¶rneÄŸi inceleyip anlamaya Ã§alÄ±ÅŸalÄ±m:

```
const func1 = () => console.log("ilk fonksiyon Ã§alÄ±ÅŸtÄ±");

const func2 = () => {
  setTimeout(() => console.log("ikinci fonksiyon Ã§alÄ±ÅŸtÄ±"), 3000);
};

const func3 = () => {
  setTimeout(() => console.log("Ã¼Ã§Ã¼ncÃ¼ fonksiyon Ã§alÄ±ÅŸtÄ±"), 2000);
};

func1();
func2();
func3();
```

YukarÄ±daki programda sÄ±rasÄ±yla fonksiyonlar Ã§aÄŸÄ±rÄ±lmÄ±ÅŸtÄ±r. Ancak ekran Ã§Ä±ktÄ±sÄ± aÅŸaÄŸÄ±daki ÅŸekilde olacaktÄ±r.

ilk fonksiyon Ã§alÄ±ÅŸtÄ±  
Ã¼Ã§Ã¼ncÃ¼ fonksiyon Ã§alÄ±ÅŸtÄ±  
ikinci fonksiyon Ã§alÄ±ÅŸtÄ±

**Fonksiyon Ä°fadeleri (Function Expressions)**

- Javascript bir deÄŸiÅŸkene fonksiyon atamaya ve daha sonra bunu fonksiyon olarak kullanmaya izin verir.

**Arrow Functions**

- Bu yÃ¶ntem ile fonksiyon oluÅŸturma ES6 ile birlikte gelmiÅŸtir.
- Daha okunabilir bir syntax yapÄ±sÄ±na sahiptir.

```
const func1 = function (param1,param1){
  return param1 + param2;
}
```

YukarÄ±da normal fonksiyonun arrow fonksiyon karÅŸÄ±lÄ±ÄŸÄ± aÅŸaÄŸÄ±daki gibidir.

```
const func1 =(param1, param2) => param1 + param2;
```

- Arrow fonksiyon **_syntax_** yazÄ±lÄ±rken parametrelerden sonra kod bloÄŸu yazÄ±lÄ±rken sadece tek bir kod Ã§alÄ±ÅŸtÄ±rÄ±lacaksa sÃ¼slÃ¼ parantezlerin yazÄ±lmasÄ±na ve de **_return_** bildiriminin yapÄ±lmasÄ±na gerek yoktur.(YukarÄ±daki arrow fonksiyon buna Ã¶rnektir.)
- Ancak parametrelerden sonra birden fazla kod bloÄŸu Ã§alÄ±ÅŸtÄ±rÄ±lacak ise sÃ¼slÃ¼ parantezlerin konulmasÄ± zorunludur ve geriye deÄŸer dÃ¶ndÃ¼rÃ¼lecek ise **_return_** bildiriminin yapÄ±lmasÄ± zorunludur. (AÅŸaÄŸÄ±daki arow fonksiyon buna Ã¶rnektir.)

```
// parantezler bize birden fazla statement yazmamÄ±zÄ± saÄŸlar.
let toplam = (a, b) => {
  let result = a + b;
  return result;
};
```

**Recursion**

- En basit tanÄ±m ÅŸekli ile bir fonksiyon kendisini tekrar Ã§aÄŸÄ±rÄ±yor ise buna recursion denir.

```
alert(pow(2, 3)); // 8
// recursion ile
function pow(x, n) {
  if (n == 1) {
    return x;
  } else {
    return x * pow(x, n - 1);
  }
}

alert(pow(2, 3)); // 8
```

YukarÄ±daki Ã¶rnekte n == 1 ise iÅŸlem yapmadan geriye 1 deÄŸerini dÃ¶ndÃ¼rerek fonksiyonun Ã§alÄ±ÅŸmasÄ± saÄŸlanÄ±r ancak n deÄŸeri 1 den farklÄ± ise **_pow_** n == 1 olana kadar Ã§aÄŸÄ±rÄ±lacak ve en sade haline gelene kadar dÃ¶necek ve sonunda sonucu bize dÃ¶ndÃ¼recektir.

```
const pow = (x, n) => n == 1 ? x : x * pow(x, n-1);
```

**Nested Functions**

- Nested functions (Ä°Ã§ iÃ§e fonksiyonlar) Javascriptte yaygÄ±nolarak kullanÄ±lan bir yapÄ±dÄ±r.
- Bir fonksiyon iÃ§erisinde baÅŸka bir foksiyon tanÄ±mladÄ±ÄŸÄ±mÄ±zda bu yapÄ±ya nedted funtions yapÄ±sÄ± denir.

**Fonksiyona Parametre (params) Atamak ve GeridÃ¶nÃ¼ÅŸ (return) Alma**

Temel kurallar aÅŸaÄŸÄ±daki gibidir.

- Bir fonksiyon bir veya daha fazla parametre alabilir veya hiÃ§ almaya dabilir.
- Bir fonksiyon geriye deÄŸer dÃ¶ndÃ¼rÃ¼yor olabilir (return) yada dÃ¶ndÃ¼rmÃ¼yor da olabilir.
- MÃ¼mkÃ¼n olduÄŸuÃ¶lÃ§Ã¼de fonksiyonun baÄŸÄ±mlÄ±lÄ±klarÄ±nÄ± azaltmak gerekir.

**_Anahtar Not:_**
Bir fonksiyon aÅŸaÄŸÄ±daki bigi kullanÄ±ldÄ±ÄŸÄ±nda ve parametreye deÄŸer atanmadÄ±ÄŸÄ±nda parametre kullanÄ±ldÄ±ÄŸÄ± noktada **_undefined_** olacak ve duruma gÃ¶re hata alÄ±nabilir.

```
const hello = (firstName) => console.log(`Merhaba ${firstName}`);

hello (); // Merhaba undefined
```

YukarÄ±daki hatalÄ± durumdan kurtulmak iÃ§in

- Kontrol saÄŸlanabilir

```
const hello = (firstName) => console.log(`Merhaba ${firstName ? firstName : ""}`);

hello (); // Merhaba
```

- Yada default parametre atanabilir.

```
const hello = (firstName = "") => console.log(`Merhaba ${firstName ? firstName : ""}`);

hello (); // Merhaba
```

Fonksiyon aÅŸaÄŸÄ±daki ÅŸekilde ise geriye deÄŸer dÃ¶ndÃ¼recektir.

```
// Geriye deÄŸer dÃ¶ndÃ¼recektir. tek kod satrÄ±rÄ± kullandÄ±ÄŸÄ±mÄ±z iÃ§in return yazmamÄ±za gerek yoktur.
const hello = (firstName = "") => `Merhaba ${firstName ? firstName : ""}`;

let user = hello ("Ziya");
console.log(user); // Merhaba Ziya
```

**Ã‡alÄ±ÅŸma SorularÄ±**
1- Biz dizi veya film listesini parametre olarak alan bir arrow fonksiyon yazalÄ±m. VerdiÄŸimiz parametreleri 1-den baÅŸlayarak alt alta yazdÄ±ran fonksiyonu yazalÄ±m.

```
const myFavoriteMovies = (movieList) => {
  movieList.forEach((movie, index) => {
    console.log(`${index + 1}: ${movie}`);
  });
};

myFavoriteMovies([
  "The Martian",
  "Passengers",
  "Fast&Furious Series",
  "Marvel Series",
  "Top Gun: Maverick",
]);
```

2- [1,2,3,4,5] aarayini alan bir arrow fonksiyon yazalÄ±m. Fonksiyon bu arrayi alsÄ±n ve sonuÃ§ta bize gene bir array dÃ¶nsÃ¼n. Geriye dÃ¶nen bu yeni array ilk aldÄ±ÄŸÄ± arraydeki tek sayilarÄ± 3, Ã§ift sayÄ±larÄ± ise 2 ile Ã§arpÄ±mÄ±ndan oluÅŸsun.

```
const newArray = (arr) =>
  arr.map((number) => (number % 2 == 0 ? number * 2 : number * 3));

let myArr = newArray([1, 2, 3, 4, 5]);
console.log(myArr);
```

**DOM Etkinlikleri ile Ã‡alÄ±ÅŸma**

```
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>DOM Eklentileri ile Ã§alÄ±ÅŸma</title>
  </head>
  <body>
    <h1 id="my-title">Frontend Kodluyoruz.</h1>
    <script src="./dom-eklentileri.js"></script>
  </body>
</html>
```

Javascript kullanarak baÅŸlÄ±ÄŸÄ±mÄ±za ulaÅŸarak Ã¼zerine tÄ±klandÄ±ÄŸÄ±nda rengini deÄŸiÅŸtirelim.

```
// BaÅŸlÄ±ÄŸÄ±mÄ±za ulaÅŸarak Ã¼zerine tÄ±klandÄ±ÄŸÄ±nda rengini deÄŸiÅŸtirelim.
const myTitle = document.querySelector("#my-title");

myTitle.addEventListener("click", clicked);

function clicked() {
  this.style.color == "red"
    ? (this.style.color = "blue")
    : (this.style.color = "red");
}
```

Ãœzerine tÄ±kladÄ±ÄŸÄ±mÄ±zda yazÄ±yÄ± deÄŸiÅŸtirelim.

```
const myTitle = document.querySelector("#my-title");

function clickON() {
  myTitle.innerHTML = "Ãœzerine tÄ±klayarak YazÄ±yÄ± DEÄÄ°ÅTÄ°RDÄ°K";
}

myTitle.addEventListener("click", clickON);
```

## 4.20- Local Storage

Web storage, web sayfalarÄ±nda yapÄ±lan deÄŸiÅŸikliklerin kaydÄ±nÄ±n tutulmasÄ± ÅŸeklinde tanÄ±mlanÄ±r. Web sayfalarÄ±nda yapÄ±lan deÄŸiÅŸikliklerin kaydÄ±nÄ± tutmak gerekebilir. Ã–rneÄŸin bir form doldurduÄŸumuzu dÃ¼ÅŸÃ¼nelim ve sayfadan Ã§Ä±kÄ±p yeniden girdiÄŸimizde formu sÄ±fÄ±rdan doldurmak sinir bozucu bir durum olarak karÅŸÄ±mÄ±za Ã§Ä±kar. BÃ¶yle durumlarda kayÄ±tlar cookie yani Ã§erezlerde tutulurdu. Ancak Ã§erezlerin 4kb ile sÄ±nÄ±rlÄ± olmasÄ± ve de Ã¼Ã§Ã¼ndÃ¼ ÅŸahÄ±slar tarafÄ±ndan kolayca eriÅŸilebilyor olmasÄ± local storage kavramÄ±nÄ±n yaygÄ±nlaÅŸmasÄ±nÄ± saÄŸlamÄ±ÅŸtÄ±r. HTML 5 ile birlikte web sayfasÄ±ndaki bu ve benzeri bilgiler local storage lerde saklanabiliyor duruma gelmiÅŸtir.

HTML 5 ile tarayÄ±cÄ±lar iki tane yerel kayÄ±t tÃ¼rÃ¼nÃ¼ desteklemektedir.

- localStorage
- sessionStorage

Bu iki kayÄ±t tÃ¼rÃ¼ arasÄ±ndaki temel fark local storage de kayÄ±tlar zaman aÅŸÄ±mÄ± olmaksÄ±zÄ±n tutulabiliyorken sessionStorage de ise oturum sonlanana kadar yada veri kaybolana kadar tutulmaktadÄ±r.

**Veri Ekle**

```
localStorage.setItem("key", "value");  // birinci parametre key yani anahtar ikinci ise value yani anahtara karÅŸÄ±lÄ±k gelen veri
```

**Veri Okuma**

```
localStorage.getItem("key");
```

**Veri Silme**

```
localStorage.removeItem("key");
	localStorage.clear();
```

[---> Ekteki Ã¶rneÄŸi inceleyeren kendiniz denemeler yapÄ±nÄ±z](./Javascript-Dersleri/localStorage/index.html)

**LocalStorage Ä°Ã§ine FarklÄ± TÃ¼rde Veriler Eklemek**
LocalStorage Ã¼zerinde farklÄ± tÃ¼rden verileri saklamak iÃ§in verileri _string_ tÃ¼rÃ¼ne dÃ¶nÃ¼ÅŸtÃ¼rmemiz gerekir.

- FarklÄ± tÃ¼rden verileri stringe Ã§evirerek localStorage de saklamak iÃ§in **_JSON.stringify()_** metodu kullanÄ±lÄ±r.
- FarklÄ± tÃ¼den verileri localStorage den Ã§ektiÄŸimizde ise **_JSON.parse()_** metodu ile Ã§evirmemiz gerekir. Aksi durumda object olarak gÃ¶rÃ¼necektir.

```
let user = {userName : "ziya", isActive : true};
localStorage.setItem("user", JSON.stringify(user));
```

**locakStorage den verileri Ã§ekme:**

```
let userInfo = JSON.parse(localStorage.getItem("user"));
```

**[---> localStorage UYGULAMA linkten inceleyiniz ](./Javascript-Dersleri/localStorage/uygulama/)**

## 4.21- Form ve Form Submit YÃ¶netimi

- Formlar iÃ§inde bulundurduklarÄ± form elementlerinin name'leri sayesinde deÄŸerlerini alÄ±p bu deÄŸerler ile iÅŸlem ypmammÄ±zÄ± saÄŸlayan yapÄ±lardÄ±r.
- Genelde backend e istek yapÄ±lacaÄŸÄ±nda kullanÄ±lÄ±rlar( Ã–rnek: verik gÃ¶nderme).
- En Ã¶nemli parametresi **_method_** parametresidir. **Method**, **"get"** ve **"post"** olamk Ã¼zere iki farklÄ± deÄŸer alabilir.

```
<form action="siteadi" method="get|post">*form elementleri*</form> // form bu ÅŸekilde tanÄ±mlanmaktadÄ±r.
```

**GET Methodu**

- form verilerini URL Ã¼zerinden gÃ¶nderir.

```
<form method="GET"><input type="text" name="yas" placeholder="YaÅŸÄ±nÄ±zÄ± giriniz." /><button type="submit">GÃ¶nder</button>
</form>
```

**POST Methodu**

- Verileri arka planda gÃ¶nderir.
- Ã–nemli verilerin (username, password,user email gibi) gÃ¶nderilmesinde kullanÄ±cÄ±ya gÃ¶sterilmeden gÃ¶nderim saÄŸlanÄ±r.

```
<form method="POST"><input type="email" name="email" placeholder="Email adresinizi giriniz." /><button type="submit">GÃ¶nder</button>
</form>
```

**GiriÅŸ (Input) elementi/etiketi**

- Form oluÅŸturulduktn sonra iÃ§erisine deÄŸiÅŸik tiplerde (text,button,ÅŸifre v.b.) giriÅŸ elementleri eklenir.

En Ã§ok kullanÄ±lan giriÅŸ tiplerine biraz gÃ¶z atalÄ±m:

- `<input type="text">` Girilen veri text tipindedir. Yani diÄŸer bir deÄŸiÅŸle string veri tipinde gelen veridir. KullanÄ±cÄ± adÄ±, ad, soyad v.b.
- `<input type="password">` Åifre tipinde veri giriÅŸi iÃ§in tercih edilir.Textboxâ€™a girilen ifadeler **â€œ\*â€** ÅŸeklinde gizlenerek gÃ¶sterilir.
- `<input type="radio">` radio button tipinde , istenilen verieleri seÃ§mek iÃ§in geliÅŸtirilen bir inputtur.
- `<input type="button">` checkbox tipinde onay gerektiren durumlarda kullanÄ±lmasÄ± iÃ§in geliÅŸtirilmiÅŸ bir inputtur.
- `<input type="submit">` Klasik buton oluÅŸturur.VarsayÄ±lan olarak herhangi bir iÅŸlem yapmaz. JavaScript vb. programlama dilleri ile birlikte iÅŸlevsel hale gelir.
- `<input type="reset">` Form iÃ§erisinde elementlere girilen verileri gÃ¶ndermede kullanÄ±lÄ±r. Action ile aÃ§Ä±lacak yeni sayfa veya mevcut sayfanÄ±n kendisine get ve post methoduna gÃ¶re deÄŸiÅŸik ÅŸekillerde veri gÃ¶nderme iÅŸlemini gerÃ§ekleÅŸtirir. methot="get" kullanÄ±lmÄ±ÅŸsa action durumunda gÃ¶re sayfanÄ±n adres Ã§ubuÄŸundaki urlâ€™in sonunda, methot="post" kullanÄ±lmÄ±ÅŸsa sayfanÄ±n arka planÄ±nda veriler saklanÄ±r.
- `<input type="color">` Button tipinde bir nesne oluÅŸturur. Form iÃ§erisinde yer alan elementlere veri girilmiÅŸ halde iken reset e basÄ±ldÄ±ÄŸÄ±nda elementler Ã¼zerinde gÃ¶rÃ¼nen bÃ¼tÃ¼n veriler silinir ve form default haline geri dÃ¶ner.
- `<input type="date">` Renk Ã§eÅŸitlerini tasarÄ±mcÄ±ya sunan ve seÃ§im yapmasÄ±nÄ± saÄŸlayan giriÅŸ veri tipidir.
- `<input type="email">` Sadece email bilgisi giriÅŸi iÃ§in tasarlanmÄ±ÅŸ bir inputtur. SayÄ± dÄ±ÅŸÄ±ndaki giriÅŸlerde, dÃ¼zgÃ¼n veri giriÅŸi yapÄ±lmasÄ± gerektiÄŸi yÃ¶nÃ¼nde uyarÄ± vermektedir. Safari dÄ±ÅŸÄ±ndaki tÃ¼m tarayÄ±cÄ±lar desteklemektedir.
- `<input type="number">` Sadece sayÄ± giriÅŸleriiÃ§in kullanÄ±lan bir inputtur. SayÄ± dÄ±ÅŸÄ±nda veri giriÅŸi yapÄ±ldÄ±ÄŸÄ±nda uyarÄ± verir.
- `<input type="range">` Bir aralÄ±k belirtmemiz gerektiÄŸinde, bu giriÅŸ tipini kullanmamÄ±z gerekmektedir. Dizi ÅŸeklinde veri gÃ¶sterimi yapar. min="baÅŸlangÄ±Ã§ deÄŸer" ve max="son deÄŸer" ile aralÄ±k belirlemesi yapÄ±lÄ±r. TÃ¼m tarayÄ±cÄ±lar tarafÄ±ndan desteklenmektedir.
- `<input type="search">` Arama yapmak iÃ§in eliÅŸtirilmiÅŸ bir inputtur. Aktif olan form iÃ§erisinde girilecek veri aranÄ±r. Sadece Google Chrome ve Safari tarafÄ±ndan desteklenmektedir.
- `<input type="time">` TarayÄ±cÄ±da saat gÃ¶sterimini saÄŸlayan tiptir. hh.mm varsayÄ±lan formatÄ±nda gÃ¶rÃ¼nÃ¼r. Element Ã¼zerinde saat belirlemesi yapÄ±lmasÄ± mÃ¼mkÃ¼ndÃ¼r. Ä°nternet Explorer ve Mozilla Firefox dÄ±ÅŸÄ±ndaki tarayÄ±cÄ±lar tarafÄ±ndan desteklenmektedir.

**onSubmit ve onChange Eventleri**

- **onSubmit** From submit olduÄŸu anda ne yapacaÄŸÄ±nÄ± sÃ¶yleyeceÄŸimiz eventtÄ±r.
- **onChange** Form'un iÃ§indeki form elementlerinin(input) value'su her deÄŸiÅŸtiÄŸinde bu deÄŸiÅŸen value'yu bizim her defasÄ±nda elde etmemize olanak saÄŸlayan eventtir.

**Ã–rnek**

```
<form method="GET">
  <input type="text" name="username" placeholder="KullanÄ±cÄ± adÄ±nÄ±zÄ± giriniz" />
  <input type="password" name="password" placeholder="Åifrenizi giriniz." />
  <button type="submit">GiriÅŸ</button>
</form>
```

YukarÄ±daki Ã¶rnek sonucunda submit ettiÄŸimizde **url** imizin deÄŸiÅŸtiÄŸini gÃ¶zlemleyebilirsiniz.

**Form Ã–zellikleri**
**- Action :** Form submit edildiÄŸinde nasÄ±l bir aksiyon alÄ±nacaÄŸÄ±nÄ± belirttiÄŸimiz koddur. Genellikle form submit iÅŸleminden sonra data server a gÃ¶nderilir.
**- METHOD :** Form metodunun hangi metodla gÃ¶nderileceÄŸini belirtir. **"Get"** veya **"Post"** request olarak, bu Ã¶zellik belirtilmemiÅŸ ise default deÄŸer olarak **"Get"** mettodu forma aktarÄ±lÄ±r.
**- AUTOCOMPLETE** formu otomatik tamamlama Ã¶zelliÄŸinin aÃ§Ä±lÄ±p kapatÄ±ldÄ±ÄŸÄ± komut, bu Ã¶zellik aÃ§Ä±k olduÄŸunda daha Ã¶nceki entry lere gÃ¶re form otomatik olarak tamamlanacaktÄ±r.
**- NOVALIDATE** aktif olduÄŸu sÃ¼rece form datamÄ±zÄ±n otomatik olarak doÄŸrulanmamasÄ±nÄ± sÃ¶yler.

**ANAHTAR NOTLAR**
Formumuzun iÃ§erisinde olmazsa olmaz sayÄ±lan temel elementler inputlar ve botunlardÄ±r. Input elementlerinin baÅŸlÄ±ca Ã¶zellikleri ÅŸu ÅŸekildedir.
**- fname** GÃ¶rÃ¼necek olan yazÄ±yÄ± belirler. Bu yazÄ± adeta bit html etiketi gibi gÃ¶rÃ¼nÃ¼r.
**- type** formunuzun text/numerik bir form olacaÄŸÄ±na karar veririz.
**- name** Inputumuzun name Ã¶zelliÄŸi dir. Genelde isimler kÃ¼Ã§Ã¼k harf ile verilir.
**- value** Input iÃ§erisinde aktif olarak gÃ¶rÃ¼necek yazÄ± iÃ§in verilir.

**Input Ä°Ã§erisinden DeÄŸer Alma**

- Input oluÅŸturma

```
let myInput=document.createElement("input"); // input oluÅŸturuldu

/* Daha sonra inputumuza Ã¶zellikler aktaralÄ±m.*/

myInput.setAttribute("id", "myInput");
myInput.setAttribute("type","text");
myInput.setAttribute("value","Buraya YazÄ±n");
```

- oluÅŸturduÄŸumuz inputu html iÃ§erisine yerleÅŸtirelim.

```
let myDiv = document.createElement ("div"); // bir div oluÅŸturup onun iÃ§erisine yerleÅŸtirelim.

/*appendChild fonksiyonu ile input u div e ekleyelim.*/
myDiv.appendChild(myInput);
```

- Inputun DeÄŸerini alalÄ±m.

```
let inputDeger = document.getElementById("myInput").value;
console.log(inputDeger); // konsolda inputun deÄŸeri gÃ¶sterildi.
```

[---> Linkteki Ã¶rneÄŸi inceleyiniz...](./Javascript-Dersleri/form/Uygulama/)

## 4.22- Array (Dizi) OluÅŸturma ve Ä°Ã§erisindeki Elemanlara UlaÅŸma

- Array birden fazla deÄŸeri (value) iÃ§erisinde barÄ±ndÄ±ran yapÄ±dÄ±r.
- Array oluÅŸturmak iÃ§in kÃ¶ÅŸeli parantez kullanÄ±lÄ±r.

```
let numbers = [1,2,3,4,5,6]; // sayÄ±lardan oluÅŸan bir array tanÄ±mlandÄ±.

let arr = [1, 2, 3, true, "eleman", {name: "ziya", scrore : 99}]; // deÄŸiÅŸik tipte parametreli elemanlara sahip bir array tanÄ±mlandÄ±.
```

**- Array Ã§erisindeki elemana ulaÅŸmak iÃ§in:** array isminden sonra kÃ¶ÅŸeli parantezler iÃ§erisinde ulaÅŸmak istenilen elemanÄ±n index numarasÄ± belirtilir. Verilen index numarasÄ± dÄ±ÅŸÄ±nda bir index verilir ise geriye **undefined** dÃ¶ner.

**Type Of Array**

- Arraylerin tipi _object_'dir.

```
let numbers = [1,2,3,4,5,6];
console.log(typeOf numbers); // object
```

**Arraylerin Deklare Edilmesi (Let || const)**

- Arraylerin let ile tanÄ±mlanan bir array daha sonradan yeniden tanÄ±mlanabilir.

```
let gunler = ['pazartesi','sali','carsamba']
gunler = ['cuma','cumartesi','pazar']; // array yeniden tanÄ±mlanarak iÃ§erik deÄŸiÅŸtirilerek yeniden tanÄ±mlanmÄ±ÅŸtÄ±r.
```

- const ile deklare edilen bir array daha sonradan yeniden tanÄ±mlanamaz.

```
let gunler = ['pazartesi','sali','carsamba']
gunler = ['cuma','cumartesi','pazar']; // Error 'TypeError: Assignment to constant variable'
```

- Ancak const ile tanÄ±mlanmÄ±ÅŸ bir arrayÄ±n index ile ulaÅŸarak elemanÄ±na deÄŸiÅŸtirmek let ile aynÄ± yapÄ±labilir.

```
let gunler = ['pazartesi','sali','carsamba']
gunler[0] = 'Cuma';

```

## 4.23- Ã–nemli Array methodlarÄ± (Diziye Yeni Eleman Eklemek, Ã‡Ä±kartmak ve GÃ¼ncellemek Diziye Yeni Eleman Eklemek)

**- Dizilere **_.push(), .unshift() ve .splice()_** metotlarÄ±yla yeni eleman ekleyebiliriz.**

```
const arr = [];

arr.push("zero");
arr.push("one");
arr.push("two");
arr.push("three");

console.log(arr); // [ 'zero', 'one', 'two', 'three' ]
```

- **_.unshift()_** methodu dizinin baÅŸÄ±na eleman ekler.

```
const arr = [];

arr.unshift(3);
arr.unshift(2);
arr.unshift(1);
arr.unshift(0);

console.log(arr); // [ 0, 1, 2, 3, 'zero', 'one', 'two', 'three' ]
```

**Diziden Elemena Silmek**

- Dizilerden eleman silmek iÃ§in **_pop(), shift(), splice()_** metodlarÄ± kullanÄ±labilir.
  **_.pop() method_**

```
const arr = [ 0, 1, 2, 3, 'zero', 'one', 'two', 'three' ];

arr.pop();
arr.pop();
arr.pop();
arr.pop();

console.log(arr); // [ 0, 1, 2, 3 ]
```

**Anahtar NOT**

- pop() methodu dizinin sonundan bir eleman siler. Her Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ±nda sondan bir eleman silinecektir.
- pop() methodu Ã§alÄ±ÅŸtÄ±ÄŸÄ±nda dizinin sonundan bir eleman silinir. Method Ã§Ä±ktÄ±sÄ± olarakda silinen eleman geriye dÃ¶ndÃ¼rÃ¼lÃ¼r. Yani istersek bir bu elemanÄ± yakalayabiliriz.
- pop() methodu parantez iÃ§erisine parametre almaz.

```
const arr = [ 0, 1, 2, 3, 'zero', 'one', 'two', 'three' ];
let decNum = arr.pop();
console.log("Silinen Eleman :", decNum); // Silinen Eleman : three
```

**_.shift() method_**

```
const arr = [ 0, 1, 2, 3, 'zero', 'one', 'two', 'three' ];

arr.shift();
arr.shift();
arr.shift();
arr.shift();

console.log(arr); // [ 'zero', 'one', 'two', 'three' ]
```

**Anahtar NOT**

- shift() methodu dizinin baÅŸÄ±ndan bir eleman siler. Her Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ±nda dizinin ilk elemanÄ± silinecektir.
- diziden silinen ilik eleman geriye dÃ¶necektir.

```
const arr = [ 0, 1, 2, 3, 'zero', 'one', 'two', 'three' ];
let decNum = arr.shift();
console.log("Silinen Eleman :", decNum); // Silinen Eleman : 0
```

**_.splice() method_**

- splice() methodu ile bir diziden hem eleman silinebilir hem de eleman eklenebilir.
- diziye eleman ekleme:

```
let nums = [1, 4];
console.log(nums); // [ 1, 4 ]

nums.splice(1,0,2,3); // 1. elemandan itibaren baÅŸla ve 0 tane sil ve 2, 3 elemanlarÄ±nÄ± ekle
console.log(nums); // [ 1, 2, 3, 4 ]
```

**Dizide Eleman GÃ¼ncellemek**
Dizinin elemanlarÄ±na index numarasÄ±nÄ± kullanarak ulaÅŸabiliriz. Bu sayede istenilen elemanÄ± gÃ¼ncelleyebiliriz.

```
let myNums = [ 1, 2, 3, 4 ];
myNums[1] = "iki";
myNums[2] = "Ã¼Ã§";
console.log(myNums); // [ 1, 'iki', 'Ã¼Ã§', 4 ]
```

**_.includes() method_**

- Bu method dizi iÃ§erisinde bir elemanÄ±n bulunup bulunmadÄ±ÄŸÄ±nÄ± kontrol eder. Ve geriye Boolean (true/false) bir deÄŸer dÃ¶ner

```
const meyveler = ["elma", "armut", "kavun", "karpuz"];

const kavunvar = meyveler.includes("kavun");
console.log("Kavun var mÄ± : ", kavunvar); // Kavun var mÄ± :  true

```

**_.slice() method_**

- .slice() mthodu dizinin bil kÄ±smÄ±nÄ± dilimlememize olanak saÄŸlar. Ve geriye yeni bir dizi olarak dÃ¶ner.
- Parantez iÃ§erisine dilimlemek istediÄŸimiz aralÄ±ÄŸÄ±n baÅŸlangÄ±Ã§ ve bitiÅŸ ve bitiÅŸ indexlerini yazarÄ±z. Burada dikkat etmemiz gereken; bitiÅŸ index i almak istediÄŸimiz aralÄ±ÄŸa dahil deÄŸildir.
- Bu method dizimizin orjinal halini deÄŸiÅŸtirmemekte yeni oluÅŸan dizi ise farklÄ± bir deÄŸiÅŸkende tutulmalÄ±dÄ±r.

```
const someNumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];

const newArray = someNumbers.slice(2, 5);  // 2. indexten itibaren baÅŸla ve 5. elemana kadar al
console.log(".slice() ile oluÅŸan yeni Array :", newArray); // .slice() ile oluÅŸan yeni Array : [ 3, 4, 5 ]
console.log(someNumbers); // [1, 2, 3, 4, 5, 6, 7, 8, 9]
```

**_.join() method_**

- Bu method bir array iÃ§erisinde yer alan bÃ¼tÃ¼n elemanlarÄ± birleÅŸtirerek _string_ bir ifade olarak geri dÃ¶ndÃ¼rÃ¼r.
- Parantes iÃ§erisinde herhangi bir deÄŸer vermez isek default deÄŸer olarak araya virgÃ¼l koyarak string ifade oluÅŸturulur.
- Mevcut diziye dokunmaz geriye string bir deÄŸer dÃ¶ner.

```
// const str = someNumbers.join(); //1. satÄ±r
// const str = someNumbers.join("-"); //2. satÄ±r
const str = someNumbers.join(""); //3. satÄ±r
// console.log(str); // 1,2,3,4,5,6,7,8,9 // 1.satÄ±r sonucu
// console.log(str); // 1-2-3-4-5-6-7-8-9 // 2.satÄ±r sonucu
console.log(str); // 123456789 // 3.satÄ±r sonucu
console.log(someNumbers); // [1, 2, 3, 4, 5, 6, 7, 8, 9]

```

**_.concat() method_**

- Bu method ise iki diziyi birleÅŸtirmekiÃ§in kullanÄ±lÄ±r.
- Geriye oluÅŸan yeni diziyi dÃ¶ner.

```
const numbers = [1, 2, 3, 4, 5, 6];
const strNums = ["bir", "iki", "Ã¼Ã§", "dÃ¶rt", "beÅŸ"];

const newNumbers = numbers.concat(strNums);

console.log(newNumbers); // [1, 2, 3, 4, 5, 6, "bir", "iki", "Ã¼Ã§", "dÃ¶rt", "beÅŸ"]
```

**_.forEach() method_**

- Bu method parametre olarak iÃ§erisine bir fonksiyon alÄ±r ve bu ÅŸekilde diziyi manipÃ¼le edebiliriz.
- Bu method sonunda **geriye herhangi bir deÄŸer DÃ–NMEZ.**

```
gunler.forEach((gun) => {
  console.log("GÃ¼nler BÃ¼yÃ¼k Harfle :", gun.toUpperCase());
});
```

**_.map() method_**

-Map metodu da forEach gibi kendisine verilen fonksiyonu dizinin her elemanÄ± iÃ§in uygular fakat forEach'ten farklÄ± olarak sonucu yeni bir dizide tutar.

- Orijinal dizi olduÄŸu gibi kalÄ±r.

```
const gunler = [
  "pazar",
  "pazartesi",
  "salÄ±",
  "Ã§arÅŸamba",
  "perÅŸembe",
  "cuma",
  "cumartesi",
];

const newDays = gunler.map((gun) => gun.toUpperCase());
console.log(newDays);  // ['PAZAR', 'PAZARTESI', 'SALI', 'Ã‡ARÅAMBA', 'PERÅEMBE', 'CUMA', 'CUMARTESI']
```

**_.some() method_**

- Dizi iÃ§erisinde bir elemanÄ±n var olup olmadÄ±ÄŸÄ±nÄ± sorgulamak iÃ§in kullanÄ±lÄ±r.
- Bu method da parametre olarak bir fonksiyon alÄ±r
- Dizinin bÃ¼tÃ¼n elemanlarÄ± ile fonksiyon ektileÅŸime girer ve sonuÃ§ olarak geriye true/false dÃ¶ner
- ektileÅŸime giren deÄŸer dizi elemanlarÄ±ndan birinde bile true olsa geriye true dÃ¶ner.

```
const sayilar = [1, 2, 3, 4, 5, 6, 7, 8, 9];

const tekSayiVarmi = sayilar.some((sayi) => sayi % 2 !== 0);
console.log(tekSayiVarmi);  //true
```

YukarÄ±daki Ã¶rnek ile aÅŸaÄŸÄ±dakiÃ¶rneÄŸi karÅŸÄ±laÅŸtÄ±rÄ±nÄ±z.

```
const sayilar = [2, 4, 6, 8, 10];

const tekSayiVarmi = sayilar.some((sayi) => sayi % 2 !== 0);
console.log(tekSayiVarmi); //false
```

EÅŸleÅŸen tek bir deÄŸer bile olsa true dÃ¶ner

```
const sayilar = [2, 4, 6, 8, 9, 10];

const tekSayiVarmi = sayilar.some((sayi) => sayi % 2 !== 0);
console.log(tekSayiVarmi); //true
```

**_.every() method_**

- every metodu belirtilen bir koÅŸulun dizideki tÃ¼m elemanlara uyup uymadÄ±ÄŸÄ±nÄ± kontrol ederiz.
- some metodunda olduÄŸu gibi, Boolean yani true veya false olarak dÃ¶ner.
- Parametre olarak bir fonksiyon alÄ±r
- True dÃ¶nebilmesi iÃ§in dizideki tÃ¼m elemanlarÄ±n fonksiyondaki koÅŸula uymasÄ± gerekir.

```
const sayilar = [2, 4, 6, 8, 9, 10];

const result = sayilar.every((sayi) => sayi >= 2); // dizinin sayÄ±larÄ± 2 den bÃ¼yÃ¼k veya eÅŸit mi?
console.log(result); // true
```

```
const sayilar = [2, 4, 6, 8, 9, 10];

const result = sayilar.every((sayi) => sayi > 5); // dizinin sayÄ±larÄ± 5 den bÃ¼yÃ¼k mÃ¼?
console.log(result); // false
```

**_.filter() method_**

- filter metodu bir dizi iÃ§erisindeki belirli bir koÅŸulu saÄŸlayan elemanlar ile yeni bir dizi oluÅŸturmamÄ±za dolayÄ±sÄ±yla dizi elemanlarÄ±nÄ± filtrelememize yarÄ±yor.
- Geriye yeni bir dizi dÃ¶ner ve oluÅŸan bu diziyi yeni bir deÄŸiÅŸkende saklÄ±yoruz.
- Orjinal dizimiz Ã¼zerinde herhangi bir deÄŸiÅŸiklik yapmayacaktÄ±r.

```
const someNumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];

const tekSayilar = someNumbers.filter((sayi) => sayi % 2 !== 0);
console.log(tekSayilar); // [ 1, 3, 5, 7, 9 ]
```

**_.find() method_**

- Bu method belirtilen koÅŸula uyan elemanÄ± bulmamÄ±zÄ± saÄŸlar.
- DiÄŸer metodlarÄ±n aksine _find_ methodu elemanÄ±n kendisini dÃ¶ner
- koÅŸulu saÄŸlayanbirden fazla eleman var ise bulduÄŸu ilk elemanÄ± dÃ¶ner.
- KoÅŸulu saÄŸlayan bir eleman bulamaz ise _undefined_ dÃ¶ner

```
const someNumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];

const sonuc = someNumbers.find((sayi) => sayi > 4);
console.log(sonuc);  // 5
```

**_.sort() method_**

- Bu method ile dizi iÃ§erisindeki elemanlarÄ± sÄ±ralama yapabiliriz.
- Orjinal dizi sÄ±ralanmÄ±ÅŸ olarak geri dÃ¶ner.
- EÄŸer parametre olarak bir fonksiyon verilmezse dizi elemanlarÄ± string'e Ã§evrilir ve UTF-16 deÄŸerlerine gÃ¶re sÄ±ralanÄ±r.
- Artan veya azalan olarak sÄ±ralamak iÃ§in (sayi1-sayi2)-> artan, (sayi2-sayi1)-> azalan ÅŸeklinde parametreler verilir. AÅŸaÄŸÄ±daki Ã¶rnekleri inceleyiniz.

```
const someNumbers = [1, 3, 2, 6, 4, 9, 5, 8, 7];
someNumbers.sort((a, b) => a - b);
console.log("Dizinin kÃ¼Ã§Ã¼kten bÃ¼yÃ¼ÄŸe sÄ±ralanmasÄ± : ", someNumbers); //Dizinin kÃ¼Ã§Ã¼kten bÃ¼yÃ¼ÄŸe sÄ±ralanmasÄ± : [1, 2, 3, 4, 5, 6, 7, 8, 9]

someNumbers.sort((a, b) => b - a);
console.log("Dizinin bÃ¼yÃ¼kten kÃ¼Ã§Ã¼ÄŸe sÄ±ralanmasÄ± : ", someNumbers); //Dizinin kÃ¼Ã§Ã¼kten bÃ¼yÃ¼ÄŸe sÄ±ralanmasÄ± : [1, 2, 3, 4, 5, 6, 7, 8, 9]
```

**_.reduce() method_**

- Bu metot dizimizi yalnÄ±zca bir deÄŸere indirger.
- Parantez iÃ§erisine parametre olarak bir fonksiyon ve accumulator'Ã¼n (toplayÄ±cÄ±nÄ±n) baÅŸlangÄ±Ã§ deÄŸeri girilir
- Bu metot orijinal diziyi deÄŸiÅŸtirmez
- Tam olarak ne yaptÄ±ÄŸÄ±nÄ± anlamak iÃ§in aÅŸaÄŸÄ±daki Ã¶rnekleri inceleyelim.

```
const sayilar = [10,20,30];

// Dizi iÃ§indeki sayÄ±larÄ± toplayarak indirgeyecek bir fonksiyon yazalÄ±m:
function indirgeyici (akumulator, sayi) {
    return akumulator + sayi;
}

// Bu fonksiyonu ve toplamaya 0'dan baÅŸlayacaÄŸÄ±mÄ±zÄ± belirten 0 sayÄ±sÄ±nÄ± metodumuza parametre olarak girelim ve sonucu bir deÄŸiÅŸkende tutalÄ±m:
const sonuc1 = sayilar.reduce(indirgeyici,0);

console.log(sonuc1);
//0 + 10 + 20 + 30 = 60 olacaÄŸÄ±ndan Ã§Ä±ktÄ± olarak 60 bekleriz.



// EÄŸer akÃ¼mÃ¼latorÃ¼mÃ¼zÃ¼ 0 yerine 5'den baÅŸlatsaydÄ±k Ã§Ä±kabilecek sonucu gÃ¶relim:

const sonuc2 = sayilar.reduce(indirgeyici, 5);

console.log(sonuc2);
// 5 + 10 + 20 + 30 = 65 olacaÄŸÄ±ndan Ã§Ä±ktÄ± olarak 65 bekleriz.
```

**Dizi Ä°Ã§erisinde Dizi TanÄ±mlama**

- Dizi iÃ§erisinde dizi bir eleman olarak bir dizi alabilir.

```
const ogrenciler = [
  ["ziya", "caylan"],
  ["ali", "veli"],
  ["hasan", "hÃ¼seyin"],
  ["salim", "malim"],
];
```

[-->Daha iyi kavrayabilmek iÃ§in linkteki Ã¶rnekleri inceleyiniz ve Ã¶rnekleri Ã§oÄŸaltÄ±nÄ±z.](./Javascript-Dersleri/Array/02-alistirmalar.js)

## 4.24- DÃ–NGÃœLER

**JavaScript for DÃ¶ngÃ¼sÃ¼ KullanÄ±mÄ±**
